
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>xuan&#39;s blog</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xuan,"> 
    
    <meta name="author" content="xuan"> 
    <link rel="alternative" href="atom.xml" title="xuan&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="../img/favicon.ico"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="../css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single" class="page">
    <div id="top">
        <a class="icon-left image-icon" href="javascript:history.back()"></a>
    </div>
    <div class="section">
        <div class="article">
            <div class="main">
                <div class="content">
                    <p>本页默认宏定义</p>
<p><span class="lang:c++ decode:true  crayon-inline ">#define N 200010</span></p>
<p><strong>倍增算法 O(n*logn)</strong><br>待排序数组r[]长度为n,放在0~n-1中，在最后面补一个0<br>da(r,sa,n+1,m);//注意是n+1,m为字符最大值<br>例如：<br>n = 8;<br>r[]=          { 1, 1, 2, 1, 1, 1, 1, 2, $ };注意r最后一位为0，其他大于0<br>rank[]=    { 4, 6, 8, 1, 2, 3, 5, 7, 0 };rank[0~n-1]为有效值，rank[n]必定为0无效值<br>sa[]=       { 8, 3, 4, 5, 0, 6, 1, 7, 2 };sa[1~n]为有效值，sa[0]必定为n是无效值<br>height[]= { 0, 0, 3, 2, 3, 1, 2, 0, 1 };height[2~n]为有效值</p>
<p>&nbsp;</p>
<pre class="lang:c++ decode:true" title="后缀数组">int wa[N],wb[N],wv[N],ws[N];  
int sa[N];      //排第i的后缀的开头位置，sa[1~n]为有效值，sa[0]必定为n是无效值  
int rank[N];    //开头位置为i的后缀排第几，rank[0~n-1]为有效值，rank[n]必定为0无效值  
                //后缀数组和名次数组为互逆运算,rank[sa[i]]==i  
int height[N];  //height[i]=suffix(sa[i-1])和suffix(sa[i])的最长公共前缀，  
                //也就是排名相邻的两个后缀的最长公共前缀。  
                //height[2~n]为有效值  

int cmp(int *r,int a,int b,int l){  
    return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];  
}  

void da(int *r,int *sa,int n,int m){  
    int i,j,p,*x=wa,*y=wb,*t;  
    for(i=0;i&lt;m;++i) ws[i]=0;  
    for(i=0;i&lt;n;++i) ws[x[i]=r[i]]++;  
    for(i=1;i&lt;m;++i) ws[i]+=ws[i-1];  
    for(i=n-1;i&gt;=0;--i) sa[--ws[x[i]]]=i;  
    for(j=1,p=1;p&lt;n;j&lt;&lt;=1,m=p){  
        for(p=0,i=n-j;i&lt;n;++i) y[p++]=i;  
        for(i=0;i&lt;n;++i) if(sa[i]&gt;=j) y[p++]=sa[i]-j;  
        for(i=0;i&lt;n;++i) wv[i]=x[y[i]];  
        for(i=0;i&lt;m;++i) ws[i]=0;  
        for(i=0;i&lt;n;++i) ws[wv[i]]++;  
        for(i=1;i&lt;m;++i) ws[i]+=ws[i-1];  
        for(i=n-1;i&gt;=0;--i) sa[--ws[wv[i]]]=y[i];  
        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;++i)  
            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;  
    }  
}  

void calheight(int *r,int *sa,int n){  
    int i,j,k=0;  
    for(i=1;i&lt;=n;++i) rank[sa[i]]=i;  
    for(i=0;i&lt;n;height[rank[i++]]=k)  
        for(k?k--:0,j=sa[rank[i]-1];r[i+k]==r[j+k];k++);  
}</pre>
&nbsp;

**DC3 算法 O(n)**
sa[]和str[]要开大三倍，所有相关数组也是三倍

&nbsp;
<pre class="lang:c++ decode:true " title="后缀数组">#define F(x) ((x)/3+((x)%3==1?0:tb))
#define G(x) ((x)&lt;tb?(x)*3+1:((x)-tb)*3+2)

int wa[N*3],wb[N*3],wv[N*3],ws[N*3];
int sa[N*3];
int rank[N*3];
int height[N*3];

int c0(int *r,int a,int b){
    return r[a]==r[b] &amp;&amp; r[a+1]==r[b+1] &amp;&amp; r[a+2]==r[b+2];
}
int c12(int k,int *r,int a,int b) {
    if(k==2)
        return r[a]&lt;r[b] || (r[a]==r[b] &amp;&amp; c12(1,r,a+1,b+1));
    else return r[a]&lt;r[b] || (r[a]==r[b] &amp;&amp; wv[a+1]&lt;wv[b+1]);
}
void sort(int *r,int *a,int *b,int n,int m) {
    int i;
    for(i=0;i&lt;n;i++)wv[i]=r[a[i]];
    for(i=0;i&lt;m;i++)ws[i]=0;
    for(i=0;i&lt;n;i++)ws[wv[i]]++;
    for(i=1;i&lt;m;i++)ws[i] +=ws[i-1];
    for(i=n-1;i&gt;=0;i--)
        b[--ws[wv[i]]]=a[i];
}
void dc3(int *r,int *sa,int n,int m) {
    int i,j,*rn=r+n;
    int *san=sa+n,ta=0,tb=(n+1)/3,tbc=0,p;
    r[n]=r[n+1]=0;
    for(i=0;i&lt;n;i++)if(i%3!=0)wa[tbc++]=i;
    sort(r+2,wa,wb,tbc,m);
    sort(r+1,wb,wa,tbc,m);
    sort(r,wa,wb,tbc,m);
    for(p=1,rn[F(wb[0])]=0,i=1;i&lt;tbc;i++)
        rn[F(wb[i])]=c0(r,wb[i-1],wb[i])?p-1:p++;
    if(p&lt;tbc)dc3(rn,san,tbc,p);
    else for(i=0;i&lt;tbc;i++)san[rn[i]]=i;
    for(i=0;i&lt;tbc;i++) if(san[i]&lt;tb)wb[ta++]=san[i]*3;
    if(n%3==1)wb[ta++]=n-1;
    sort(r,wb,wa,ta,m);
    for(i=0;i&lt;tbc;i++)wv[wb[i]=G(san[i])]=i;
    for(i=0,j=0,p=0;i&lt;ta &amp;&amp; j&lt;tbc;p++)
        sa[p]=c12(wb[j]%3,r,wa[i],wb[j])?wa[i++]:wb[j++];
    for(;i&lt;ta;p++)sa[p]=wa[i++];
    for(;j&lt;tbc;p++)sa[p]=wb[j++];
}
//str和sa也要三倍
void da(int *str,int *sa,int *rank,int *height,int n,int m) {
    for(int i=n;i&lt;n*3;i++)
        str[i]=0;
    dc3(str,sa,n+1,m);
    int i,j,k=0;
    for(i=0;i&lt;=n;i++)rank[sa[i]]=i;
    for(i=0;i&lt;n;i++) {
        if(k) k--;
        j=sa[rank[i]-1];
        while(str[i+k]==str[j+k]) k++;
        height[rank[i]]=k;
    }
}</pre>
&nbsp;

## Example

**1、最长公共前缀**

给定一个字符串，询问某两个后缀的最长公共前缀。
求两个后缀的最长公共前缀可以转化为求某个区间上的最小值。
用ST预处理。

* * *

&nbsp;

_重复子串：字符串R 在字符串L 中至少出现两次，则称R 是L 的重复子串。_

**2、可重叠最长子串**
给定一个字符串，求最长重复子串，这两个子串可以重叠。
答案等于height数组的最大值

* * *

&nbsp;

**3、不可重叠最长子串**
[POJ 1743 Musical Theme](http://poj.org/problem?id=1743)
给定一个字符串，求最长重复子串，这两个子串不能重叠。
二分答案+判定

设二分长度为k，则将height分组，同组内height[i]不小于k，根据任意两个后缀的公共前缀定义这样就保证了组内任意两个后缀的公共前缀长至少为k，再判断一下组内sa的最大值和最小值差是否不小于k即可，若存在，则表示坐标差至少为k，一定不会重叠，反之不存在。
<pre class="lang:c++ decode:true " title="POJ 1743">int judge(int n,int k){
    int l=sa[0],r=sa[0];
    for(int i=0; i&lt;n; ++i){
        if(height[i]&lt;k) l=r=sa[i];
        else{
            l=min(l,sa[i]);
            r=max(r,sa[i]);
            if(r-l&gt;k) return 1;
        }
    }
    return 0;
}

int solve(int n){
    int l=0,r=n,mid,ans=-1;
    while(l&lt;=r){
        mid=(l+r)&gt;&gt;1;
        if(judge(n,mid)){
            ans=mid;
            l=mid+1;
        }
        else
            r=mid-1;
    }
    return ans;
}

int main()
{
    int n;
    int s[N];
    int ans;
    while(scanf("%d",&amp;n),n){
        for(int i=0; i&lt;n; ++i)
            scanf("%d",&amp;s[i]);
        if(n==1){
            printf("0\n");
            continue;
        }
        for(int i=0; i&lt;n-1; ++i)
            s[i]=s[i+1]-s[i]+90;
        s[n-1]=0;
        da(s,sa,n,200);
        calheight(s,sa,n-1);
        ans=solve(n)+1;
        if(ans&lt;5)
            ans=0;
        printf("%d\n",ans);
    }
    return 0;
}</pre>

<hr>
<p>&nbsp;</p>
<p><strong>4、可重叠的k次最长重复子串</strong><br><a href="http://poj.org/problem?id=3261" target="_blank" rel="noopener">POJ 3261 Milk Patterns</a><br>给定一个字符串，求至少出现k次的最长重复子串，这k个子串可以重叠。<br>二分答案+判断<br>这题的做法和上一题差不多，也是先二分答案，然后将后缀分成若干组。不同的是，这里要判断的是有没有一个组的后缀个数不小于k。如果有，那么存在k 个相同的子串满足条件，否则不存在。</p>
<pre class="lang:c++ decode:true " title="POJ 3261">int judge(int len,int n,int k){
    int cnt=1;
    for(int i=2;i&lt;=n;++i){
        if(height[i]&lt;len)cnt=1;
        else{
            cnt++;
            if(cnt&gt;=k) return 1;
        }
    }
    return 0;
}

int solve(int n,int k){
    int l=1,r=n,mid;
    int ans;
    while(l&lt;=r){
        mid=(l+r)&gt;&gt;1;
        if(judge(mid,n,k)){
            ans=mid;
            l=mid+1;
        }else
            r=mid-1;
    }
    return ans;
}
int s[N];
int main(){
    int i;
    int m;
    int n,k;
    while(~scanf("%d%d",&amp;n,&amp;k)){
        m=0;
        for(i=0;i&lt;n;++i){
            scanf("%d",&amp;s[i]);
            m=max(m,s[i]);
        }
        s[n]=0;

        da(s,n+1,m+1);
        calheight(s,n);
        printf("%d\n",solve(n,k));
    }
    return 0;
}</pre>

<hr>
<p>&nbsp;</p>
<p><strong>5、不相同的子串的个数</strong><br><a href="http://www.spoj.com/problems/DISUBSTR/" target="_blank" rel="noopener">SPOJ DISUBSTR</a><br>给定一个字符串，求不相同的子串的个数。</p>
<p>因为任意子串一定是某个后缀的前缀，那么原问题则等价于所有后缀之间不相同前缀的个数，按 照suffix[sa[i]]i递增顺序计算，每次新加一个后缀，比产生n-sa[k]个前缀，其中有height[i]个 是和前面的前缀是相同的，故减去，suffix[sa[k]]将贡献n-sa[k]-height[k]个子串。 也可以用总数（可相同子串个数）- height[]（重复的个数）</p>
<pre class="lang:c++ decode:true " title="SPOJ DISUBSTR">int solve(int n){
    int ans=0;
    for(int i=1;i&lt;=n;++i){
        ans+=(n-sa[i]-height[i]);
    }
    return ans;
}
char s[N];
int main(){
    int t;
    int len;
    scanf("%d",&amp;t);
    while(t--){
            scanf("%s",s);
            len=strlen(s);
            s[len]=0,s[len+1]='\0';
            da(s,sa,len+1,N);
            calheight(s,sa,len);
            printf("%d\n",solve(len));
    }
    return 0;
}</pre>

<hr>
<p>&nbsp;</p>
<p><em>连续重复串：如果一个字符串L是由某个字符串S重复R次而得到的，则称L是一个连续重复串。R是这个字符串的重复次数。</em></p>
<p><strong>6、重复次数最多的连续重复子串</strong></p>
<p><a href="http://poj.org/problem?id=3693" target="_blank" rel="noopener">POJ 3693 Maximum repetition substring</a></p>
<p>给定一个字符串，求重复次数最多的连续重复子串。</p>
<p>&nbsp;</p>
<p>先穷举长度L，然后求长度为L的子串最多能连续出现多少次<br>既然长度为L的串重复出现，那么str[0],str[l],str[2<em>l]……中肯定有两个连续的出现在字符串中。<br>那么就枚举连续的两个，然后从这两个字符前后匹配，看最多能匹配多远。<br>即以str[i</em>l],str[i<em>l+l]前后匹配，这里是通过查询suffix(i</em>l),suffix(i<em>l+l)的最长公共前缀<br>通过rank值能找到i</em>l,与i<em>l+l的排名，我们要查询的是这段区间的height的最小值，通过RMQ预处理<br>达到查询为0(1)的复杂度，<br>设LCP长度为M, 则答案显然为M / L + 1, 但这不一定是最好的, 因为答案的首尾不一定再我们枚举的位置上. 我的解决方法是, 我们考虑M % L的值的意义, 我们可以认为是后面多了M % L个字符, 但是我们更可以想成前面少了(L - M % L)个字符! 所以我们求后缀j </em> L - (L - M % L)与后缀(j + 1) * L - (L - M % L)的最长公共前缀。<br>即把之前的区间前缀L-M%L即可。<br>然后把可能取到最大值的长度L保存，由于 题目要求字典序最小，通过sa数组进行枚举，取到的第一组，肯定是字典序最小的。</p>
<pre class="lang:c++ decode:true " title="POJ 3693">int mm[N];
int best[20][N];
void initRMQ(int n)
{
    mm[0]=-1;
    for(int i=1;i&lt;=n;i++)
        mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1];
    for(int i=1;i&lt;=n;i++)best[0][i]=i;
    for(int i=1;i&lt;=mm[n];i++)
        for(int j=1;j+(1&lt;&lt;i)-1&lt;=n;j++)
        {
            int a=best[i-1][j];
            int b=best[i-1][j+(1&lt;&lt;(i-1))];
            if(height[a]&lt;height[b])best[i][j]=a;
            else best[i][j]=b;
        }
}
int askRMQ(int a,int b)
{
    int t;
    t=mm[b-a+1];
    b-=(1&lt;&lt;t)-1;
    a=best[t][a];b=best[t][b];
    return height[a]&lt;height[b]?a:b;
}
int lcp(int a,int b)
{
    a=rank[a];b=rank[b];
    if(a&gt;b)swap(a,b);
    return height[askRMQ(a+1,b)];
}
char str[N];
int r[N];
int a[N];
int main()
{
    int iCase=0;
    while(scanf("%s",str)==1)
    {
        if(strcmp(str,"#")==0)break;
        iCase++;
        int n=strlen(str);
        for(int i=0;i&lt;=n;i++)r[i]=str[i];
        build_sa(r,n+1,128);
        getHeight(r,n);
        initRMQ(n);
        int cnt=0,mmax=0;
        for(int l=1;l&lt;n;l++)
        {
            for(int i=0;i+l&lt;n;i+=l)
            {
                int t1=lcp(i,i+l);
                int step=t1/l+1;
                int  k=i-(l-t1%l);
                if(k&gt;=0&amp;&amp;t1%l)
                {
                    if(lcp(k,k+l)&gt;=t1)step++;
                }
                if(step&gt;mmax)
                {
                    mmax=step;
                    cnt=0;
                    a[cnt++]=l;
                }
                else if(step==mmax)
                    a[cnt++]=l;
            }
        }
        int len=-1,st;
        for(int i=1;i&lt;=n&amp;&amp;len==-1;i++)
        {
            for(int j=0;j&lt;cnt;j++)
            {
                int l=a[j];
                if(lcp(sa[i],sa[i]+l)&gt;=(mmax-1)*l)
                {
                    len=l;
                    st=sa[i];
                    break;
                }
            }
        }
        str[st+len*mmax]=0;
        printf("Case %d: %s\n",iCase,str+st);
    }
    return 0;
}</pre>

<hr>
<p>&nbsp;</p>
<p><em>公共子串:如果字符串L同时出现在字符串A和字符串B中，则称字符串L是字符串A和字符串B的公共子串。</em></p>
<p><strong>7、最长公共子串</strong><br><a href="http://poj.org/problem?id=2774" target="_blank" rel="noopener">POJ 2774 Long Long Message</a><br>给定两个字符串A 和B，求最长公共子串。<br>由于任何一个子串都是某个后缀的前缀，则等价于求A的后缀和B的后缀的最长公共前缀的最大值。 先将第二个字符串写在第一个字符串后面，中间用一个没有出现过的字符隔开，再求这个新的字符串 的后缀数组，那么是不是所有的height值中的最大值就是答案呢?不一定!有可能这两个后缀是在同一 个字符串中的，实际上只有当suffix(sa[i-1])和suffix(sa[i])不是同一个字符串中的两个后缀时， height[i]的最大值才是答案。</p>
<pre class="lang:c++ decode:true " title="POJ 2774">char s[N];
int len1,len2,len;

int solve(){
    int i;
    int ans=0;
    for(i=1;i&lt;=len;++i){
        if((sa[i]&lt;len1&amp;&amp;sa[i-1]&gt;len1)||(sa[i]&gt;len1&amp;&amp;sa[i-1]&lt;len1))
            ans=max(ans,height[i]);
    }
    return ans;
}
int main(){

    scanf("%s",s);
    len1=strlen(s);
    s[len1]='$',s[len1+1]='\0';
    scanf("%s",s+len1+1);
    len=strlen(s);
    len2=len-len1-1;
    s[len]='0',s[len+1]='\0';

    da(s,sa,len+1,200);
    calheight(s,sa,len);

    printf("%d\n",solve());
    return 0;
}</pre>

<hr>
<p>&nbsp;</p>
<p><strong>8、不小于k个字符串中的最长子串</strong><br><a href="http://poj.org/problem?id=3294" target="_blank" rel="noopener">POJ 3294 Life Forms</a><br>给定n个字符串，求出现在不小于k个字符串中的最长子串。<br>将n个字符串连起来，中间用不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案。<br>用和例3同样的方法将后缀分成若干组，判断每组的后缀是否出现在不小于k个的原串中。</p>
<pre class="lang:c++ decode:true " title="POJ 3294">int cnt;
char s[110][1100];
int r[N];
int sum[N];

int getid(int n,int x){
    int l=1,r=n,mid;
    int ret=0;
    while(l&lt;=r){
        mid=(l+r)&gt;&gt;1;
        if(sum[mid]&gt;x){
            ret=mid;
            r=mid-1;
        }else{
            l=mid+1;
        }
    }
    return ret;
}

int judge(int k,int len,int n,int out=0){
    int cnt=1;
    int vis[110];
    int i,j,q;
    memset(vis,0,sizeof(vis));
    for(i=2;i&lt;=len+1;++i){
        if(height[i]&gt;=k){
            int id=getid(n,sa[i-1]);
            vis[id]=1;
            id=getid(n,sa[i]);
            if(!vis[id]){
                vis[id]=1;
                cnt++;
            }
            if(cnt&gt;(n/2)&amp;&amp;out==0)return 1;
        }else{
            if(cnt&gt;(n/2)&amp;&amp;out==1){
                for(j=sa[i-1],q=0;q&lt;k;++j,++q)
                    printf("%c",r[j]+'a'-100);
                printf("\n");
            }
            cnt=1;
            memset(vis,0,sizeof(vis));
        }
    }
    return 0;
}

void solve(int n,int len){
    int l=0,r=len,mid;
    int ans=0;
    while(l&lt;=r){
        mid=(l+r)&gt;&gt;1;
        if(judge(mid,len,n)){
            ans=mid;
            l=mid+1;
        }else
            r=mid-1;
    }
    if(ans==0){
        printf("?\n");
    }else{
        judge(ans,len,n,1);
    }
}

int main(){
    int n;
    int cas=1;
    int i,j;
    while(scanf("%d",&amp;n),n){
        if(cas!=1)
            printf("\n");
        cas++;
        if(n==1){
            scanf("%s",s[0]);
            printf("%s\n",s[0]);
            continue;
        }
        sum[0]=0;
        for(i=1;i&lt;=n;++i){
            scanf("%s",s[i]);
            sum[i]=sum[i-1]+strlen(s[i])+1;
        }
        int len=0;
        for(i=1;i&lt;=n;++i){
            for(j=0;j&lt;strlen(s[i]);++j){
                r[len++]=s[i][j]-'a'+100;
            }
            r[len++]=i;
        }
        --len;
        r[len]=1,r[len+1]='\0';
        da(r,sa,len+1,'z'+110);
        calheight(r,sa,len);
        solve(n,len);
    }
    return 0;
}</pre>

<hr>
<p>&nbsp;</p>
<p><strong>9、每个字符串至少出现两次且不重叠的最长子串</strong><br><a href="http://www.spoj.com/problems/PHRASES/en/" target="_blank" rel="noopener">SPOJ PHRASES Relevant Phrases of Annihilation</a><br>给定n 个字符串，求在每个字符串中至少出现两次且不重叠的最长子串。<br>做法和上题大同小异，也是先将n 个字符串连起来，中间用不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，再将后缀分组。判断的时候，要看是否有一组后缀在每个原来的字符串中至少出现两次，并且在每个原来的字符串中，后缀的起始位置的最大值与最小值之差是否不小于当前答案（判断能否做到不重叠，如果题目中没有不重叠的要求，那么不用做此判断）。</p>
<pre class="lang:c++ decode:true " title="SPOJ PHRASES">char s[20][10000];
int r[N];
int sum[20];
int li[20],ri[20];

int getid(int x,int n,int len){
    int l=1,r=n,mid;
    int ret=0;
    while(l&lt;=r){
        mid=(l+r)&gt;&gt;1;
        if(sum[mid]&gt;x){
            ret=mid;
            r=mid-1;
        }else
            l=mid+1;
    }
    return ret;
}

int judge(int k,int n,int len){
    int i,j;
    for(i=1;i&lt;=n;++i){
        li[i]=INF,ri[i]=0;
    }
    for(i=2;i&lt;=len;++i){
        if(height[i]&gt;=k){
            int id=getid(sa[i-1],n,len);
            li[id]=min(li[id],sa[i-1]);
            ri[id]=max(ri[id],sa[i-1]);
            id=getid(sa[i],n,len);
            li[id]=min(li[id],sa[i]);
            ri[id]=max(ri[id],sa[i]);
            for(j=1;j&lt;=n;++j){
                if(ri[j]-li[j]&lt;k)
                    break;
            }
            if(j==n+1)return 1;
        }else{
            for(j=1;j&lt;=n;++j){
                li[j]=INF,ri[j]=0;
            }
        }
    }
    return 0;
}

int solve(int n,int len){
    int l=0,r=len,mid;
    int ans=0;
    while(l&lt;=r){
        mid=(l+r)&gt;&gt;1;
        if(judge(mid,n,len)){
            ans=mid;
            l=mid+1;
        }else{
            r=mid-1;
        }
    }
    return ans;
}

int main(){
    int t;
    int n;
    int i,j;
    scanf("%d",&amp;t);
    while(t--){
        scanf("%d",&amp;n);
        sum[0]=0;
        for(i=1;i&lt;=n;++i){
            scanf("%s",s[i]);
            sum[i]=sum[i-1]+strlen(s[i])+1;
        }
        int len=0;
        for(i=1;i&lt;=n;++i){
            int l=strlen(s[i]);
            for(j=0;j&lt;l;++j){
                r[len++]=s[i][j]-'a'+20;
            }
            r[len++]=i;
        }
        r[--len]=0;
        da(r,sa,len+1,'z'-'a'+30);
        calheight(r,sa,len);
        printf("%d\n",solve(n,len));
    }
    return 0;
}</pre>

<hr>
<p>&nbsp;</p>
<p><strong>10、出现或反转后出现在每个字符串中的最长子串</strong></p>
<p><a href="http://poj.org/problem?id=1226" target="_blank" rel="noopener">POJ 1226 Substrings</a><br>给定n 个字符串，求出现或反转后出现在每个字符串中的最长子串。<br>这题不同的地方在于要判断是否在反转后的字符串中出现。其实这并没有加大题目的难度。只需要先将每个字符串都反过来写一遍，中间用一个互不相同的且没有出现在字符串中的字符隔开，再将n 个字符串全部连起来，中间也是用一个互不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，再将后缀分组。判断的时候，要看是否有一组后缀在每个原来的字符串或反转后的字符串中出现。</p>
<p><pre class="lang:c++ decode:true " title="POJ 3294">char s[110][110];<br>int r[N];<br>int sum[110];<br>int vis[110];</pre></p>
<p>int getid(int x,int n,int len){<br>    int l=1,r=n,mid;<br>    int ret=0;<br>    while(l&lt;=r){<br>        mid=(l+r)&gt;&gt;1;<br>        if(sum[mid]&gt;x){<br>            ret=mid;<br>            r=mid-1;<br>        }else<br>            l=mid+1;<br>    }<br>    return ret;<br>}</p>
<p>int judge(int k,int n,int len){<br>    int i,j;<br>    memset(vis,0,sizeof(vis));<br>    for(i=2;i&lt;=len;++i){<br>        if(height[i]&gt;=k){<br>            vis[getid(sa[i-1],n,len)]=1;<br>            vis[getid(sa[i],n,len)]=1;<br>            for(j=1;j&lt;=n;++j){<br>                if(!vis[j])<br>                    break;<br>            }<br>            if(j==n+1) return 1;<br>        }else{<br>            memset(vis,0,sizeof(vis));<br>            //vis[getid(sa[i],n,len)]=1;<br>        }<br>    }<br>    return 0;<br>}</p>
<p>int solve(int n,int len){<br>    int l=0,r=len,mid;<br>    int ans=0;<br>    while(l&lt;=r){<br>        mid=(l+r)&gt;&gt;1;<br>        if(judge(mid,n,len)){<br>            ans=mid;<br>            l=mid+1;<br>        }else{<br>            r=mid-1;<br>        }<br>    }<br>    return ans;<br>}</p>
<p>int main(){<br>    int t;<br>    int n;<br>    int i,j;<br>    scanf(“%d”,&amp;t);<br>    while(t–){<br>        scanf(“%d”,&amp;n);<br>        sum[0]=0;<br>        for(i=1;i&lt;=n;++i){<br>            scanf(“%s”,s[i]);<br>            sum[i]=sum[i-1]+strlen(s[i])<em>2+2;<br>        }<br>        int len=0;<br>        for(i=1;i&lt;=n;++i){<br>            int l=strlen(s[i]);<br>            for(j=0;j&lt;l;++j){<br>                r[len++]=s[i][j]-‘A’+220;<br>            }<br>            r[len++]=i</em>2-1;<br>            for(j=l-1;j&gt;=0;–j){<br>                r[len++]=s[i][j]-‘A’+220;<br>            }<br>            r[len++]=i*2;<br>        }<br>        r[–len]=0;<br>        da(r,sa,len+1,’z’-‘A’+230);<br>        calheight(r,sa,len);<br>        printf(“%d\n”,solve(n,len));<br>    }<br>}<br><br>&nbsp;</p>

                </div>
            </div>
        </div>
    </div>
</div>

</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="../js/plugin.js"></script>
<script src="../js/diaspora.js"></script>
<link rel="stylesheet" href="../photoswipe/photoswipe.css">
<link rel="stylesheet" href="../photoswipe/default-skin/default-skin.css">
<script src="../photoswipe/photoswipe.min.js"></script>
<script src="../photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>