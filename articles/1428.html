<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="../css/images/logo.png">
  
  <title>
    
      面试常见问题 | Xuan&#39;s Blog
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="../js/qrious.js"></script>
<script src="../js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="../index.html">
      <div class="logo"></div>
      <span>Xuan's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="../index.html" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="../index.html" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>面试常见问题</h2>
  <p class="post-date">2016-08-16</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>之前为了面试总结的，不是很全，一些比较基础的就没有写下来，这里很多是可以作为加分项的吧。</p>
<p>Java的话这里有个比较全的总结：<a href="http://www.jianshu.com/p/b5f1121c3a2d" target="_blank" rel="external">http://www.jianshu.com/p/b5f1121c3a2d</a></p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>Java面向对象的基本特性？</strong></p>
<ul>
<li>抽象：将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。</li>
<li>继承：从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到信息的类被称为子类（派生类）。</li>
<li>封装：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。</li>
<li>多态：允许不同子类的对象对同一消息做出不同的响应。<br>&nbsp;</li>
</ul>
<p><strong>抽象类与接口的区别？</strong></p>
<ul>
<li>抽象类需被子类继承；接口需被类实现</li>
<li>抽象类中可以有普通变量；而接口中只能有静态常量</li>
<li>抽象类中方法访问权限不限；接口中的方法都为public；</li>
<li>抽象类中可以只方法声明，也可以做方法实现；接口中只能有方法声明（JDK8 中可以有静态方法和默认方法）</li>
<li>抽象类只能单基础；接口可以多继承接口，也可以被实现多个接口<br>&nbsp;</li>
</ul>
<p><strong>为什么内部类访问的局部变量必须被final修饰？</strong></p>
<p>因为生命周期不同。局部变量在方法结束后就会被销毁，但内部类对象并不一定，这样就会导致内部类引用了一个不存在的变量。</p>
<p>所以编译器会在内部类中生成一个局部变量的拷贝，这个拷贝的生命周期和内部类对象相同，就不会出现上述问题。</p>
<p>但这样就导致了其中一个变量被修改，两个变量值可能不同的问题。为了解决这个问题，编译器就要求局部变量需要被final修饰，以保证两个变量值相同。</p>
<p>在JDK8之后，编译器不要求内部类访问的局部变量必须被final修饰，但局部变量值不能被修改（无论是方法中还是内部类中），否则会报编译错误。利用javap查看编译后的字节码可以发现，编译器已经加上了final。</p>
<p>源码：</p>
<p><pre class="lang:java decode:true ">public class Main {</pre></p>
<pre><code>void test(){
    int i = 1;
    class Inner{
        public void func(){
            System.out.println(i);
        }
    }
    new Inner().func();
}
</code></pre><p>}<br>字节码：</p>
<p><pre class="lang:java mark:24 decode:true">Compiled from “Main.java”<br>public class Main {<br>  public Main();<br>    Code:<br>       0: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.”&lt;init&gt;”:()V<br>       4: return</pre></p>
<p>  void test();<br>    Code:<br>       0: iconst_1<br>       1: istore_1<br>       2: new           #2                  // class Main$1Inner<br>       5: dup<br>       6: aload_0<br>       7: iload_1<br>       8: invokespecial #3                  // Method Main$1Inner.”&lt;init&gt;”:(LMain;I)V<br>      11: invokevirtual #4                  // Method Main$1Inner.func:()V<br>      14: return<br>}</p>
<p>Compiled from “Main.java”<br>class Main$1Inner {<br>  final int val$i;</p>
<p>  final Main this$0;</p>
<p>  Main$1Inner();<br>    Code:<br>       0: aload_0<br>       1: aload_1<br>       2: putfield      #1                  // Field this$0:LMain;<br>       5: aload_0<br>       6: iload_2<br>       7: putfield      #2                  // Field val$i:I<br>      10: aload_0<br>      11: invokespecial #3                  // Method java/lang/Object.”&lt;init&gt;”:()V<br>      14: return</p>
<p>  public void func();<br>    Code:<br>       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       3: aload_0<br>       4: getfield      #2                  // Field val$i:I<br>       7: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V<br>      10: return<br>}<br><br>&nbsp;</p>
<p><strong>你了解哪些JDK1.8的新特性？</strong></p>
<ul>
<li>接口的默认方法和静态方法<br>JDK8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，也可以定义被static修饰的静态方法</li>
<li>对HashMap进行了改进，当单个桶的元素个数大于6时就会将实现改为红黑树实现，以避免构造重复的hashCode的攻击</li>
<li>JDK8拓宽了注解的应用场景，注解几乎可以使用在任何元素上，并且允许在同一个地方多次使用同一个注解</li>
<li>Lambda表达式<br>详细参考：<a href="http://blog.csdn.net/yczz/article/details/50896975" target="_blank" rel="external">http://blog.csdn.net/yczz/article/details/50896975</a></li>
</ul>
<p>&nbsp;</p>
<p><strong>你知道哪些JDK中用到的设计模式？</strong></p>
<ul>
<li>装饰模式：java.io<br><a href="http://qsxuan.com/wp-content/uploads/2016/08/java.io装饰模式.png" target="_blank" rel="external"><img src="http://qsxuan.com/wp-content/uploads/2016/08/java.io装饰模式.png" alt="java.io装饰模式"></a></li>
<li>单例模式：Runtime类</li>
<li>简单工厂模式：Integer.valueOf方法</li>
<li>享元模式：String常量池、Integer.valueOf(int i)、Character.valueOf(char c)</li>
<li>迭代器模式：Iterator</li>
<li>职责链模式：ClassLoader的双亲委派模型</li>
<li>解释器模式：正则表达式java.util.regex.Pattern<br>详细参考：<a href="http://blog.csdn.net/gtuu0123/article/details/6114197" target="_blank" rel="external">http://blog.csdn.net/gtuu0123/article/details/6114197</a></li>
</ul>
<p>&nbsp;</p>
<p><strong>是否可以继承String类？</strong></p>
<p>String类是final类故不可以继承，一切由final修饰过的都不能继承</p>
<p>&nbsp;</p>
<p><strong>String和StringBuffer、StringBuilder的区别</strong></p>
<ul>
<li>可变性：<br>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。<br>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</li>
<li>线程安全性：<br>String中的对象是不可变的，也就可以理解为常量，线程安全。<br>AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li>性能：<br>每次对String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer和StringBuilder每次都会对 对象本身进行操作，而不是生成新的对象并改变对象引用。<br>&nbsp;</li>
</ul>
<p><strong>hashCode和equals方法的关系</strong></p>
<p>equals为true，hashcode必相等；hashcode相等，equals可能不为true</p>
<p>&nbsp;</p>
<p><strong>什么是泛型、为什么要使用以及泛型擦除</strong></p>
<p>泛型，即“参数化类型”。</p>
<p>创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。</p>
<p>Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦除。 泛型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。</p>
<p>类型擦除的主要过程如下：</p>
<ol>
<li>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</li>
<li>移除所有的类型参数。<br>&nbsp;</li>
</ol>
<p><strong>Error、Exception区别</strong></p>
<p>Error类和Exception类的父类都是throwable类，他们的区别是：</p>
<p>Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</p>
<p>Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</p>
<p>&nbsp;</p>
<p><strong>Unchecked Exception和Checked Exception，各列举几个</strong></p>
<ul>
<li><p>Unchecked Exception:</p>
<ul>
<li>指的是程序的瑕疵或逻辑错误，并且在运行时无法恢复。</li>
<li>包括Error与RuntimeException及其子类，如：OutOfMemoryError, UndeclaredThrowableException, IllegalArgumentException, IllegalMonitorStateException, NullPointerException, IllegalStateException, IndexOutOfBoundsException等。</li>
<li>语法上不需要声明抛出异常。</li>
</ul>
</li>
<li><p>Checked Exception:</p>
<ul>
<li>代表程序不能直接控制的无效外界情况（如用户输入，数据库问题，网络异常，文件丢失等）</li>
<li>除了Error和RuntimeException及其子类之外，如：ClassNotFoundException, NamingException, <span style="line-height: 1.5;">ervletException, SQLException, IOException等。</span></li>
<li>需要try catch处理或throws声明抛出异常。<br>&nbsp;</li>
</ul>
</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><strong>Java集合类图</strong></p>
<p><a href="http://qsxuan.com/wp-content/uploads/2016/08/Java集合类图.gif" target="_blank" rel="external"><img src="http://qsxuan.com/wp-content/uploads/2016/08/Java集合类图.gif" alt="Java集合类图"></a></p>
<p>&nbsp;</p>
<p><strong>HashMap和Hashtable区别</strong></p>
<ul>
<li>Hashtable的方法前面都有synchronized来同步，是线程安全的；HashMap未经同步，是非线程安全的。</li>
<li>Hashtable不允许null值(key和value都不可以) ；HashMap允许null值(key和value都可以)。</li>
<li>Hashtable有一个contains(Object value)功能和containsValue(Object value)功能一样。</li>
<li>Hashtable使用Enumeration进行遍历；HashMap使用Iterator进行遍历。</li>
<li>Hashtable中hash数组默认大小是11，增加的方式是 old*2+1；HashMap中hash数组的默认大小是16，而且一定是2的指数。</li>
<li>哈希值的使用不同，Hashtable直接使用对象的hashCode； HashMap重新计算hash值，而且用与代替求模。<br>&nbsp;</li>
</ul>
<p><strong>ArrayList和vector区别</strong></p>
<ul>
<li>Vector的方法前面都有synchronized来同步，是线程安全的；而ArrayList是非线程安全的。</li>
<li>List第一次创建的时候，会有一个初始大小，随着不断向List中增加元素，当 List 认为容量不够的时候就会进行扩容。Vector缺省情况下自动增长原来一倍的数组长度，ArrayList增长原来的50%。<br>&nbsp;</li>
</ul>
<p><strong>Collection和Collections的区别</strong></p>
<p>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
<p>java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p>&nbsp;</p>
<p><strong>ConcurrentHashMap如何保证线程安全</strong></p>
<p>JDK 1.7及以前：</p>
<p>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<p>详细参考：</p>
<p><a href="http://www.cnblogs.com/ITtangtang/p/3948786.html" target="_blank" rel="external">http://www.cnblogs.com/ITtangtang/p/3948786.html</a></p>
<p><a href="http://qifuguang.me/2015/09/10/[Java并发包学习八]深度剖析ConcurrentHashMap/" target="_blank" rel="external">http://qifuguang.me/2015/09/10/[Java并发包学习八]深度剖析ConcurrentHashMap/</a></p>
<p>JDK 1.8：</p>
<p>Segment虽保留，但已经简化属性，仅仅是为了兼容旧版本。</p>
<p>插入时使用CAS算法：unsafe.compareAndSwapInt(this, valueOffset, expect, update)。 CAS(Compare And Swap)意思是如果valueOffset位置包含的值与expect值相同，则更新valueOffset位置的值为update，并返回true，否则不更新，返回false。插入时不允许key或value为null</p>
<p>与Java8的HashMap有相通之处，底层依然由“数组”+链表+红黑树；</p>
<p>底层结构存放的是TreeBin对象，而不是TreeNode对象；</p>
<p>CAS作为知名无锁算法，那ConcurrentHashMap就没用锁了么？当然不是，当hash值与链表的头结点相同还是会synchronized上锁，锁链表。</p>
<p>&nbsp;</p>
<p><strong>为什么HashMap不是线程安全</strong></p>
<p>多线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会死循环。</p>
<p>&nbsp;</p>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p><strong>引用的类型以及应用</strong></p>
<p><a href="http://zhangjunhd.blog.51cto.com/113473/53092" target="_blank" rel="external">http://zhangjunhd.blog.51cto.com/113473/53092</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><strong>i++在多线程环境下是否存在问题，怎么解决？</strong></p>
<p>虽然递增操作++i是一种紧凑的语法，使其看上去只是一个操作，但这个操作并非原子的，因而它并不会作为一个不可分割的操作来执行。实际上，它包含了三个独立的操作：读取count的值，将值加1，然后将计算结果写入count。这是一个“读取 - 修改 - 写入”的操作序列，并且其结果状态依赖于之前的状态。所以在多线程环境下存在问题。</p>
<p>要解决自增操作在多线程环境下线程不安全的问题，可以选择使用Java提供的原子类，如AtomicInteger或者使用synchronized同步方法。</p>
<p>&nbsp;</p>
<p><strong>多线程的实现方式</strong></p>
<ul>
<li>继承Thread类，重写run()方法</li>
<li>实现Runnable接口，重写run()方法</li>
<li>使用ExecutorService、Callable、Future实现有返回结果的多线程<br>&nbsp;</li>
</ul>
<p><strong>线程的状态</strong></p>
<ul>
<li>New （新生）<br>如用new Thread()创建一个新线程，这个线程还没有开始运行</li>
<li>Runnable （可运行）<br>一旦调用start方法，线程处于可运行状态。处于此状态的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。</li>
<li>Blocked （被阻塞）<br>当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变为非阻塞状态。</li>
<li>Waiting （等待）<br>当线程等待另一个线程通知调度器一个条件时，进入等待状态，如调用Object.wait()方法时，需要等待其他线程调用Object.notify()或Object.notifyAll()</li>
<li>Timed waiting （计时等待）<br>有几个方法有一个超时参数，调用它们导致线程进入计时等待状态。这一状态将一直保持到超时期满或者接收到适当的通知。</li>
<li>Terminated （被终止）<br>因run方法正常退出而自然死亡。或因为一个没有捕获的异常终止了run方法而意外死亡。<br>&nbsp;</li>
</ul>
<p><strong>如何停止一个线程</strong></p>
<p>停止一个线程意味着在任务处理完任务之前停掉正在做的操作，也就是放弃当前的操作。停止一个线程可以用Thread.stop()方法，但最好不要用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且是已被废弃的方法。</p>
<p>在java中有以下3种方法可以终止正在运行的线程：</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>
<li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li>
<li>使用interrupt方法中断线程。<br>详细参考：<a href="http://www.cnblogs.com/greta/p/5624839.html" target="_blank" rel="external">http://www.cnblogs.com/greta/p/5624839.html</a></li>
</ul>
<p>&nbsp;</p>
<p><strong>什么是线程安全？</strong></p>
<p>线程安全就是多线程访问同一代码，不会产生不确定的结果。</p>
<p>&nbsp;</p>
<p><strong>如何保证线程安全？</strong></p>
<ul>
<li>对非安全的代码进行加锁控制</li>
<li>使用线程安全的类</li>
<li>多线程并发情况下，线程共享的变量改为方法级的局部变量。<br>&nbsp;</li>
</ul>
<p><strong>Synchronized如何使用</strong></p>
<p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>
<ul>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象。当一个线程获得了对象锁，其他线程如果调用此对象同一个锁的其他同步块，也会阻塞。</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象。</li>
<li>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象<br>&nbsp;</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong>new与newInstance()的区别</strong></p>
<ul>
<li>new是一个关键字，它是调用new指令创建一个对象，然后调用构造方法来初始化这个对象，可以使用带参数的构造器</li>
<li>newInstance()是Class的一个方法，在这个过程中，是先取了这个类的不带参数的构造器Constructor，然后调用构造器的newInstance方法来创建对象。<br>Class.newInstance()不能带参数，如果要带参数需要取得对应的构造器，然后调用该构造器的Constructor.newInstance(Object … initargs)方法<br>&nbsp;</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><strong>什么情况下会导致处理器从用户态向内核态转换？</strong></p>
<ul>
<li>程序请求操作系统服务，执行系统调用</li>
<li>程序运行时产生中断事件，运行程序被中断，转向中断处理程序处理</li>
<li>程序运行时产生异常事件，运行程序被打断，转向异常处理程序工作<br>&nbsp;</li>
</ul>
<p><strong>进程和线程的区别</strong></p>
<ul>
<li>进程：具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位</li>
<li>线程：进程中的一个执行流程，一个进程中可以运行多个线程。线程可与同属一个进程的其它线程共享进程所拥有的资源。<br>&nbsp;</li>
</ul>
<p><strong>进程状态</strong></p>
<p>就绪态、运行态、阻塞态</p>
<p>新建态、终止态</p>
<p>挂起就绪态、挂起阻塞态</p>
<p>&nbsp;</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>红黑树的五个性质</strong></p>
<ul>
<li>每个结点要么是红的，要么是黑的。</li>
<li>根结点是黑的。</li>
<li>每个叶结点，即空结点（NIL）是黑的。</li>
<li>如果一个结点是红的，那么它的俩个儿子都是黑的。</li>
<li>对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。<br>&nbsp;</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p><strong>Spring的注入方式有哪些？</strong></p>
<ul>
<li>setter注入</li>
<li>构造器注入<br>&nbsp;</li>
</ul>
<p><strong>FactoryBean和BeanFactory有什么区别？</strong></p>
<ul>
<li>BeanFactory：它是一个Factory，也就是IoC容器或对象工厂，在Spring中，所有的Bean都是由BeanFactory（也就是IoC容器）来进行管理的。</li>
<li>FactoryBean：它是一个Bean，是一个能产生或装饰对象生成的工厂Bean，它的实现与设计模式中的工厂模式和装饰模式类似.<br>&nbsp;</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><strong>事务的四个特性？
</strong></p>
<ul>
<li>原子性</li>
<li>隔离性</li>
<li>一致性</li>
<li>持久性<br>&nbsp;</li>
</ul>
<p><strong>事务的隔离级别</strong></p>
<ul>
<li>Read Uncommitted（读取未提交内容）：所有事务都可以看到其他未提交事务的执行结果</li>
<li>Read Committed（读取提交内容）：一个事务只能看见已经提交事务所做的改变</li>
<li>Repeatable Read（可重读）：</li>
<li>Serializable（可串行化）<br>&nbsp;</li>
</ul>
<h2 id="其他问题清单"><a href="#其他问题清单" class="headerlink" title="其他问题清单"></a>其他问题清单</h2><p>J2SE基础</p>
<p>1. 九种基本数据类型的大小，以及他们的封装类。</p>
<p>2. Switch能否用string做参数？</p>
<p>3. equals与==的区别。</p>
<p>4. Object有哪些公用方法？</p>
<p>5. Java的四种引用，强弱软虚，用到的场景。</p>
<p>6. Hashcode的作用。</p>
<p>7. ArrayList、LinkedList、Vector的区别。</p>
<p>8. String、StringBuffer与StringBuilder的区别。</p>
<p>9. Map、Set、List、Queue、Stack的特点与用法。</p>
<p>10. HashMap和HashTable的区别。</p>
<p>11. HashMap和ConcurrentHashMap的区别，HashMap的底层源码。</p>
<p>12. TreeMap、HashMap、LindedHashMap的区别。</p>
<p>13. Collection包结构，与Collections的区别。</p>
<p>14. try catch finally，try里有return，finally还执行么？</p>
<p>15. Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。</p>
<p>16. Java面向对象的三个特征与含义。</p>
<p>17. Override和Overload的含义去区别。</p>
<p>18. Interface与abstract类的区别。</p>
<p>19. Static class 与non static class的区别。</p>
<p>20. java多态的实现原理。</p>
<p>21. 实现多线程的两种方法：Thread与Runable。</p>
<p>22. 线程同步的方法：sychronized、lock、reentrantLock等。</p>
<p>23. 锁的等级：方法锁、对象锁、类锁。</p>
<p>24. 写出生产者消费者模式。</p>
<p>25. ThreadLocal的设计理念与作用。</p>
<p>26. ThreadPool用法与优势。</p>
<p>27. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</p>
<p>28. wait()和sleep()的区别。</p>
<p>29. foreach与正常for循环效率对比。</p>
<p>30. Java IO与NIO。</p>
<p>31. 反射的作用于原理。</p>
<p>32. 泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt;。</p>
<p>33. 解析XML的几种方式的原理与特点：DOM、SAX、PULL。</p>
<p>34. Java与C++对比。</p>
<p>35. Java1.7与1.8新特性。</p>
<p>36. 设计模式：单例、工厂、适配器、责任链、观察者等等。</p>
<p>37. JNI的使用。</p>
<p>Java里有很多很杂的东西，有时候需要你阅读源码，大多数可能书里面讲的不是太清楚，需要你在网上寻找答案。</p>
<p>推荐书籍：《java核心技术卷I》《Thinking in java》《java并发编程》《effictive java》《大话设计模式》</p>
<p>&nbsp;</p>
<p>JVM</p>
<p>1. 内存模型以及分区，需要详细到每个区放什么。</p>
<p>2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。</p>
<p>3. 对象创建方法，对象的内存分配，对象的访问定位。</p>
<p>4. GC的两种判定方法：引用计数与引用链。</p>
<p>5. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</p>
<p>6. GC收集器有哪些？CMS收集器与G1收集器的特点。</p>
<p>7. Minor GC与Full GC分别在什么时候发生？</p>
<p>8. 几种常用的内存调试工具：jmap、jstack、jconsole。</p>
<p>9. 类加载的五个过程：加载、验证、准备、解析、初始化。</p>
<p>10. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。</p>
<p>11. 分派：静态分派与动态分派。</p>
<p>JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。</p>
<p>推荐书籍：《深入理解java虚拟机》</p>
<p>&nbsp;</p>
<p>操作系统</p>
<p>1. 进程和线程的区别。</p>
<p>2. 死锁的必要条件，怎么处理死锁。</p>
<p>3. Window内存管理方式：段存储，页存储，段页存储。</p>
<p>4. 进程的几种状态。</p>
<p>5. IPC几种通信方式。</p>
<p>6. 什么是虚拟内存。</p>
<p>7. 虚拟地址、逻辑地址、线性地址、物理地址的区别。</p>
<p>推荐书籍：《深入理解现代操作系统》</p>
<p>&nbsp;</p>
<p>TCP/IP</p>
<p>1. OSI与TCP/IP各层的结构与功能，都有哪些协议。</p>
<p>2. TCP与UDP的区别。</p>
<p>3. TCP报文结构。</p>
<p>4. TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。</p>
<p>5. TCP拥塞控制。</p>
<p>6. TCP滑动窗口与回退N针协议。</p>
<p>7. Http的报文结构。</p>
<p>8. Http的状态码含义。</p>
<p>9. Http request的几种类型。</p>
<p>10. Http1.1和Http1.0的区别</p>
<p>11. Http怎么处理长连接。</p>
<p>12. Cookie与Session的作用于原理。</p>
<p>13. 电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。</p>
<p>14. Ping的整个过程。ICMP报文是什么。</p>
<p>15. C/S模式下使用socket通信，几个关键函数。</p>
<p>16. IP地址分类。</p>
<p>17. 路由器与交换机区别。</p>
<p>网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。</p>
<p>推荐书籍：《TCP/IP协议族》</p>
<p>&nbsp;</p>
<p>数据结构与算法</p>
<p>1. 链表与数组。</p>
<p>2. 队列和栈，出栈与入栈。</p>
<p>3. 链表的删除、插入、反向。</p>
<p>4. 字符串操作。</p>
<p>5. Hash表的hash函数，冲突解决方法有哪些。</p>
<p>6. 各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。</p>
<p>7. 快排的partition函数与归并的Merge函数。</p>
<p>8. 对冒泡与快排的改进。</p>
<p>9. 二分查找，与变种二分查找。</p>
<p>10. 二叉树、B+树、AVL树、红黑树、哈夫曼树。</p>
<p>11. 二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。</p>
<p>12. 图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。</p>
<p>13. KMP算法。</p>
<p>14. 排列组合问题。</p>
<p>15. 动态规划、贪心算法、分治算法。（一般不会问到）</p>
<p>16. 大数据处理：类似10亿条数据找出最大的1000个数………等等</p>
<p>&nbsp;</p>
<p>三、 项目</p>
<p>关于项目，这部分每个人的所做的项目不同，所以不能具体的讲。项目不再与好与不好，在于你会不会包装，有时候一个很low的项目也能包装成比较高大上的项目，多用一些专业名词，突出关键字，能使面试官能比较容易抓住重点。在聊项目的过程中，其实你的整个介绍应该是有一个大体的逻辑，这个时候是在考验你的表达与叙述能力，所以好好准备很重要。</p>
<p>面试官喜欢问的问题无非就几个点：</p>
<p>1. XXX（某个比较重要的点）是怎么实现的？</p>
<p>2. 你在项目中遇到的最大的困难是什么，怎么解决的？</p>
<p>3. 项目某个部分考虑的不够全面，如果XXXX，你怎么优化？</p>
<p>4. XXX（一个新功能）需要实现，你有什么思路？</p>
<p>其实你应该能够预料到面试官要问的地方，请提前准备好，如果被问到没有准备到的地方，也不要紧张，一定要说出自己的想法，对不对都不是关键，主要是有自己的想法，另外，你应该对你的项目整体框架和你做的部分足够熟悉。</p>
<p>四、 其他</p>
<p>你应该问的问题</p>
<p>面试里，最后面完之后一般面试官都会问你，你有没有什么要问他的。其实这个问题是有考究的，问好了其实是有加分的，一般不要问薪资，主要应该是：关于公司的、技术和自身成长的。</p>
<p>以下是我常问的几个问题，如果需要可以参考：</p>
<p>1. 贵公司一向以XXX著称，能不能说明一下公司这方面的特点？</p>
<p>2. 贵公司XXX业务发展很好，这是公司发展的重点么？</p>
<p>3. 对技术和业务怎么看？</p>
<p>4. 贵公司一般的团队是多大，几个人负责一个产品或者业务？</p>
<p>5. 贵公司的开发中是否会使用到一些最新技术？</p>
<p>6. 对新人有没有什么培训，会不会安排导师？</p>
<p>7. 对Full Stack怎么看？</p>
<p>8. 你觉得我有哪些需要提高的地方？</p>
<p>&nbsp;</p>
<h2 id="常考代码"><a href="#常考代码" class="headerlink" title="常考代码"></a>常考代码</h2><p><pre class="lang:java decode:true ">package com.qsxuan.algorithm;</pre></p>
<p>import java.util.Arrays;</p>
<p>/**</p>
<ul>
<li>快排</li>
<li>按升序排列<br>*</li>
<li><p>@author xuan<br>*/<br>public class QuickSort {</p>
<p> private int[] data;</p>
<p> public boolean sort(int[] nums) {</p>
<pre><code>if (nums == null) return false;
data = nums;
sortInternal(0, data.length - 1);
return true;
</code></pre><p> }</p>
<p> private void sortInternal(int L, int R) {</p>
<pre><code>//assert data != null;
if (L &amp;gt;= R) return;
int l = L;
int r = R;
int midNum = data[l];
while (l &amp;lt; r) {
    while (l &amp;lt; r &amp;amp;&amp;amp; data[r] &amp;gt;= midNum) r--;
    data[l] = data[r];
    while (l &amp;lt; r &amp;amp;&amp;amp; data[l] &amp;lt;= midNum) l++;
    data[r] = data[l];
}
data[l] = midNum;
sortInternal(L, l - 1);
sortInternal(l + 1, R);
</code></pre><p> }</p>
<p> public static void main(String[] args) {</p>
<pre><code>int[] nums = {3, 6, 0, 9, 4, 1, 8, 8, 5, 2};
QuickSort quickSort = new QuickSort();
quickSort.sort(nums);
System.out.println(Arrays.toString(nums));
</code></pre><p> }<br>}<br><br>&nbsp;<br><pre class="lang:java decode:true ">package com.qsxuan.algorithm;</pre></p>
</li>
</ul>
<p>import java.util.Arrays;</p>
<p>/**</p>
<ul>
<li>最小堆，下标从1开始</li>
<li>实现降序排列</li>
<li>时间复杂度O(nlogn)</li>
<li>空间复杂度O(1)<br>*</li>
<li><p>@author xuan<br>*/<br>public class HeapSort {<br> private int[] data;<br> private int size;</p>
<p> /**</p>
<ul>
<li>初始化<br>*</li>
<li><p>@param data 待排序数组<br>*/<br>public HeapSort(int[] data) {<br> this.data = data;<br> this.size = data.length - 1;<br> build();<br>}</p>
<p>/**</p>
</li>
<li><p>建立最小堆<br>*/<br>private void build() {<br> for (int i = size / 2; i &gt;= 1; i–)</p>
<pre><code>adjust(i, size);
</code></pre><p>}</p>
<p>/**</p>
</li>
<li>从rt开始向下调整<br>*</li>
<li>@param rt 当前结点</li>
<li><p>@param sz 堆大小<br>*/<br>private void adjust(int rt, int sz) {<br> int l = rt &lt;&lt; 1;<br> int r = rt &lt;&lt; 1 | 1;<br> if (l &gt; sz) l = rt;<br> if (r &gt; sz) r = rt;<br> int mn = data[l] &lt; data[r] ? l : r;</p>
<p> if (data[mn] &lt; data[rt]) {</p>
<pre><code>int temp = data[mn];
data[mn] = data[rt];
data[rt] = temp;
adjust(mn, sz);
</code></pre><p> }<br>}</p>
<p>/**</p>
</li>
<li><p>排序，降序<br>*/<br>public void sort() {<br> int sz = size;<br> while (sz &gt; 0) {</p>
<pre><code>int temp = data[1];
data[1] = data[sz];
data[sz] = temp;
adjust(1, --sz);
</code></pre><p> }<br>}</p>
<p>public static void main(String[] args) {<br> int[] num = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br> HeapSort heapSort = new HeapSort(num);<br> heapSort.sort();<br> System.out.println(Arrays.toString(num));<br>}<br>}<br><br>&nbsp;<br><pre class="lang:java decode:true ">package com.qsxuan.algorithm;</pre></p>
</li>
</ul>
</li>
</ul>
<p>import java.util.Arrays;</p>
<p>/**</p>
<ul>
<li>最小堆，下标从1开始</li>
<li>用最小堆实现找出n个数中前k大的数</li>
<li>先用最小堆保存前k个数，之后每次新读入一个数便判断与堆顶的数大小，</li>
<li>如果大于即代替原来的堆顶，再对堆进行调整</li>
<li>时间复杂度O(nlogk)</li>
<li>空间复杂度O(k)</li>
<li>适合于读取数据时内存较小</li>
<li>若内存大于3.75G可用线性时间求第k大的方法{@link com.qsxuan.algorithm.FindKthMax}<br>*</li>
<li><p>@author xuan<br>*/<br>public class Heap {<br> private int[] data;<br> private int size;<br> private static final int DEFAULT_CAPACITY = 10;</p>
<p> public int getSize() {</p>
<pre><code>return size;
</code></pre><p> }</p>
<p> public int[] toArray() {</p>
<pre><code>return Arrays.copyOf(data, size + 1);
</code></pre><p> }</p>
<p> public Heap() {</p>
<pre><code>this.data = new int[DEFAULT_CAPACITY];
</code></pre><p> }</p>
<p> public Heap(int capacity) {</p>
<pre><code>this.data = new int[capacity + 1];
</code></pre><p> }</p>
<p> public Heap(int[] data) {</p>
<pre><code>this.data = data;
this.size = data.length - 1;
adjustAll();
</code></pre><p> }</p>
<p> private void swap(int a, int b) {</p>
<pre><code>int temp = data[a];
data[a] = data[b];
data[b] = temp;
</code></pre><p> }</p>
<p> private void adjustAll() {</p>
<pre><code>for (int i = size / 2; i &amp;gt;= 1; --i)
    adjustDown(i);
</code></pre><p> }</p>
<p> private void adjustDown(int rt) {</p>
<pre><code>int l = rt &amp;lt;&amp;lt; 1;
int r = rt &amp;lt;&amp;lt; 1 | 1;
if (l &amp;gt; size) l = rt;
if (r &amp;gt; size) r = rt;
int minPos = data[l] &amp;lt; data[r] ? l : r;

if (data[minPos] &amp;lt; data[rt]) {
    swap(minPos, rt);
    adjustDown(minPos);
}
</code></pre><p> }</p>
<p> private void adjustUp(int rt) {</p>
<pre><code>int f = rt &amp;gt;&amp;gt; 1;
if (f &amp;lt; 1) f = rt;

if (data[rt] &amp;lt; data[f]) {
    swap(rt, f);
    adjustUp(f);
}
</code></pre><p> }</p>
<p> public boolean add(int num) {</p>
<pre><code>int newPos;
if (capacityCheck(size + 1)) {
    newPos = size + 1;
    data[newPos] = num;
    adjustUp(newPos);
    size++;
} else {
    if (num &amp;gt; data[1])
        newPos = 1;
    else
        return false;
    data[newPos] = num;
    adjustDown(newPos);
}

return true;
</code></pre><p> }</p>
<p> private boolean capacityCheck(int newSize) {</p>
<pre><code>return newSize &amp;lt;= data.length - 1;
</code></pre><p> }</p>
<p> public static void main(String[] args) {</p>
<pre><code>int[] num = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
Heap heap = new Heap(3);
for (int i = 1; i &amp;lt;= 10; i++) {
    heap.add(num[i]);
}
System.out.println(Arrays.toString(heap.toArray()));
</code></pre><p> }<br>}<br><br>&nbsp;</p>
</li>
</ul>
<p>&nbsp;</p>
<p><pre class="lang:java decode:true ">package com.qsxuan.algorithm;</pre></p>
<p>/**</p>
<ul>
<li>利用快排思想{@link com.qsxuan.algorithm.QuickSort}线性时间求n个数中第k大</li>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)<br>*</li>
<li><p>@author xuan<br>*/<br>public class FindKthMax {</p>
<p> private int[] data;</p>
<p> public int findKthMax(int[] nums, int k) {</p>
<pre><code>if (nums == null || k &amp;gt; nums.length) return -1;
this.data = nums;
int size = nums.length;
return findKthMaxInternal(0, size - 1, k);
</code></pre><p> }</p>
<p> private int findKthMaxInternal(int L, int R, int kth) {</p>
<pre><code>//assert data != null;
if (L == R) return data[L];
int midNum = data[L];
int l = L;
int r = R;
while (l &amp;lt; r) {
    while (l &amp;lt; r &amp;amp;&amp;amp; data[r] &amp;gt;= midNum) r--;
    data[l] = data[r];
    while (l &amp;lt; r &amp;amp;&amp;amp; data[l] &amp;lt;= midNum) l++;
    data[r] = data[l];
}
data[l] = midNum;
if (R - l + 1 == kth) return midNum;
else if (R - l + 1 &amp;gt; kth) return findKthMaxInternal(l + 1, R, kth);
else return findKthMaxInternal(L, l - 1, kth - (R - l + 1));
</code></pre><p> }</p>
<p> public static void main(String[] args) {</p>
<pre><code>int[] nums = {3, 6, 0, 9, 4, 1, 8, 8, 5, 2};
FindKthMax findKthMax = new FindKthMax();
int ans = findKthMax.findKthMax(nums, 3);
System.out.println(ans);
</code></pre><p> }<br>}<br><br>&nbsp;</p>
</li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Java"><span class="toc-nav-text">Java</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#基础"><span class="toc-nav-text">基础</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#集合"><span class="toc-nav-text">集合</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#虚拟机"><span class="toc-nav-text">虚拟机</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#多线程"><span class="toc-nav-text">多线程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#反射"><span class="toc-nav-text">反射</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#操作系统"><span class="toc-nav-text">操作系统</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#数据结构"><span class="toc-nav-text">数据结构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Spring"><span class="toc-nav-text">Spring</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#数据库"><span class="toc-nav-text">数据库</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#其他问题清单"><span class="toc-nav-text">其他问题清单</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#常考代码"><span class="toc-nav-text">常考代码</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://qinshaoxuan.com/articles/1428.html';
    var banner = ''
    if (banner !== 'undefined') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "yanm1ng";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "面试常见问题",
        owner: "yanm1ng",
        repo: "yanm1ng.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2017 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="../js/script.js"></script>
  </body>
</html>