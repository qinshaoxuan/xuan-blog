<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="../css/images/logo.png">
  
  <title>
    
      2015年计算机学院程序设计大赛结果及题解 | Xuan&#39;s Blog
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="../js/qrious.js"></script>
<script src="../js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="../index.html">
      <div class="logo"></div>
      <span>Xuan's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="../index.html" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="../index.html" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>2015年计算机学院程序设计大赛结果及题解</h2>
  <p class="post-date">2015-12-21</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>我出的有4道题，其他4道题的题解：h<a href="http://hate13.com/?p=742" target="_blank" rel="external">ate13</a></p>
<p><img src="http://qsxuan.com/wp-content/uploads/2015/12/院赛结果.png" alt="院赛结果"></p>
<hr>
<p>&nbsp;</p>
<h2 id="镜像翻转"><a href="#镜像翻转" class="headerlink" title="镜像翻转"></a>镜像翻转</h2><p>可以在纸上推出n=1,2,3的答案，分别为3,8,15，就可以看出规律，$$ans=(n+1)^2-1$$，或者其他的变形</p>
<p>其实题目中第二种跳跃操作的无论颜色是迷惑人的，最短路线就是异色才能跳，因为越过同色之后会出现需要退后的情况，反而浪费了步数。</p>
<p>如果限制只能越过异色的，那么就只有一种走法。那就是先形成红蓝相间的情况，之后就很好走了。</p>
<p>本来之前是准备出小数据让你们能BFS过的，但是自己写了一发，发现n=7的时候都要跑1S（也有可能是我的姿势不对），所以直接改成找规律了。然后强行模了一发QQ号~</p>
<p>&nbsp;</p>
<p>标程：</p>
<p><pre class="lang:c++ decode:true ">#include&lt;cstdio&gt;</pre></p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>#include&lt;cstring&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;string&gt;</p>
<p>#include&lt;map&gt;<br>using namespace std;</p>
<p>#define pb push_back</p>
<p>#define LL long long</p>
<p>#define N 100005</p>
<p>#define INF 1&lt;&lt;30</p>
<p>int main(){<br>    //freopen(“C:\Users\F\Desktop\in.txt”, “r”, stdin);<br>    //freopen(“C:\Users\F\Desktop\out.txt”, “w”, stdout);<br>    LL n;<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%lld”,&amp;n);<br>        printf(“%lld\n”,(((n+1)%459440330)*((n+1)%459440330)-1)%459440330);<br>    }<br>    return 0;<br>}<br><br>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="字符矩阵"><a href="#字符矩阵" class="headerlink" title="字符矩阵"></a>字符矩阵</h2><p>这道题就是考察字符串相关的知识，在我印象中字典树应该是个很基础的东西了。本来预计算法题最有可能被AC的就是这道题，但是结果出乎意料- -</p>
<p>方法很容易想到，就是直接枚举每一个起点，然后开始DFS，只是DFS的时候不能暴力比对每一个字符串，那样对于每一层循环时间都是字符串个数*字符串长度，这样肯定会超时。</p>
<p>之后就会想到一个可以用字典树来优化，DFS向下传递字典树的结点地址，这样就不会重复比对。</p>
<p>而且要注意每次找到一个字符串之后要从字典树里删去，不然也会超时。</p>
<p>&nbsp;</p>
<p>标程：</p>
<p><pre class="lang:c++ decode:true ">#include&lt;cstdio&gt;</pre></p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cstring&gt;<br>using namespace std;</p>
<p>#define pb push_back</p>
<p>#define LL long long</p>
<p>#define INF 1&lt;&lt;30</p>
<p>#define NODE 1000005</p>
<p>#define N 1100</p>
<p>char mpt[N][N];<br>char str[N][N];<br>int vis[N][N];<br>int dir[4][2]={0,1,1,0,0,-1,-1,0};<br>int n,m;</p>
<p>int Next[NODE][26]; //数组建树<br>int cnt[NODE];<br>int val[NODE];<br>int node;</p>
<p>int ans[N];<br>int anscnt=0;</p>
<p>void init() {<br>    node = 1;<br>    memset(Next[0], 0, sizeof(Next[0]));<br>    memset(vis,0,sizeof(vis));<br>    memset(val,0,sizeof(val));<br>    anscnt=0;<br>}</p>
<p>void add(char *s,int id) {<br>    int len = strlen(s);<br>    int cur = 0, p;<br>    for(int i = 0; i &lt; len; ++i) {<br>        p = s[i] -‘a’;<br>        if(Next[cur][p] == 0) {<br>            memset(Next[node], 0, sizeof(Next[node]));<br>            val[node] = 0;<br>            cnt[node]=0;<br>            Next[cur][p] = node++;<br>        }<br>        cnt[Next[cur][p]]++;<br>        cur = Next[cur][p];<br>    }<br>    val[cur]=id;<br>}</p>
<p>void del(char *s){<br>    int len = strlen(s);<br>    int cur = 0, p;<br>    for(int i = 0; i &lt; len; ++i) {<br>        p = s[i] -‘a’;<br>        cnt[Next[cur][p]]–;<br>        cur = Next[cur][p];<br>    }<br>    val[cur]=0;<br>}</p>
<p>bool judge(int x,int y,int cur){<br>    if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)return false;<br>    if(vis[x][y])return false;<br>    if(!cur||!cnt[cur])return false;<br>    return true;<br>}</p>
<p>void dfs(int x,int y,int cur){<br>    if(val[cur]){<br>            ans[anscnt++]=val[cur];<br>            del(str[val[cur]]);<br>    }<br>    for(int i=0;i&lt;4;++i){<br>        int nx=x+dir[i][0];<br>        int ny=y+dir[i][1];<br>        int p = mpt[nx][ny] -‘a’;<br>        if(judge(nx,ny,Next[cur][p])){<br>            vis[nx][ny]=1;<br>            dfs(nx,ny,Next[cur][p]);<br>            vis[nx][ny]=0;<br>        }<br>    }<br>}</p>
<p>int main() {<br>    //freopen(“C:\Users\F\Desktop\in.txt”, “r”, stdin);<br>    //freopen(“C:\Users\F\Desktop\out.txt”, “w”, stdout);</p>
<pre><code>int T;
scanf(&quot;%d&quot;,&amp;amp;T);
while(T--){
    init();
    int q;
    scanf(&quot;%d%d%d&quot;,&amp;amp;n,&amp;amp;m,&amp;amp;q);
    for(int i=1;i&amp;lt;=n;++i){
        scanf(&quot;%s&quot;,mpt[i]+1);
    }
    for(int i=1;i&amp;lt;=q;++i){
        scanf(&quot;%s&quot;,str[i]);
        add(str[i],i);
    }

    for(int i=1;i&amp;lt;=n;++i){
        for(int j=1;j&amp;lt;=m;++j){
            int p = mpt[i][j] -&apos;a&apos;;
            if(judge(i,j,Next[0][p])){
                vis[i][j]=1;
                dfs(i,j,Next[0][p]);
                vis[i][j]=0;
            }
        }
    }
    sort(ans,ans+anscnt);
    for(int i=0;i&amp;lt;anscnt;++i){
        if(i!=0)
            printf(&quot; &quot;);
        printf(&quot;%d&quot;,ans[i]);
    }
    printf(&quot;\n&quot;);
}

return 0;
</code></pre><p>}<br>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="数组变换"><a href="#数组变换" class="headerlink" title="数组变换"></a>数组变换</h2><p>这道题其实不是我想出来的，是队友说的。</p>
<p>解法就是线段树。</p>
<p>其中的难点在于区间异或，我们可以把每一个数转换为二进制，根据数据范围拆成31颗线段树，那么求和就转换成了求区间内1的个数，再对应转换为10进制。而异或就变成了1与0的个数交换或者不变。</p>
<p>加法操作是随便加的，没有难度。</p>
<p>注意写代码的姿势，姿势不好也是会超时的，比如用结构体，比如不用位运算，都是会超时的。</p>
<p>&nbsp;</p>
<p>标程：</p>
<p><pre class="lang:c++ decode:true ">#include&lt;cstdio&gt;</pre></p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>#include&lt;cstring&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;string&gt;</p>
<p>#include&lt;map&gt;<br>using namespace std;</p>
<p>#define pb push_back</p>
<p>#define LL long long</p>
<p>#define N 100005</p>
<p>#define INF 1&lt;&lt;30</p>
<p>#define BIT 31</p>
<p>#define lson l,m,rt&lt;&lt;1</p>
<p>#define rson m+1,r,rt&lt;&lt;1|1</p>
<p>LL sum[N&lt;&lt;2][BIT];<br>LL lazy[N&lt;&lt;2][BIT];</p>
<p>void pushup(int rt){<br>    for(int i=0;i&lt;BIT;++i){<br>        sum[rt][i]=sum[rt&lt;&lt;1][i]+sum[rt&lt;&lt;1|1][i];<br>    }<br>}</p>
<p>void pushdown(int l,int r,int rt){<br>    for(int i=0;i&lt;BIT;++i){<br>        if(lazy[rt][i]){<br>            int m=(l+r)&gt;&gt;1;<br>            lazy[rt&lt;&lt;1][i]^=lazy[rt][i];<br>            lazy[rt&lt;&lt;1|1][i]^=lazy[rt][i];<br>            sum[rt&lt;&lt;1][i]=(m-l+1)-sum[rt&lt;&lt;1][i];<br>            sum[rt&lt;&lt;1|1][i]=(r-m)-sum[rt&lt;&lt;1|1][i];<br>            lazy[rt][i]=0;<br>        }<br>    }<br>}</p>
<p>void build(int l,int r,int rt){<br>    memset(lazy[rt],0,sizeof(lazy[rt]));<br>    if(l==r){<br>        int num;<br>        scanf(“%d”,&amp;num);<br>        for(int i=0;i&lt;BIT;++i){<br>            sum[rt][i]=(num&gt;&gt;i)&amp;1;<br>        }<br>        return;<br>    }<br>    int m=(l+r)&gt;&gt;1;<br>    build(lson);<br>    build(rson);<br>    pushup(rt);<br>}</p>
<p>void update_add(int x,LL p,int l,int r,int rt){<br>    if(l==r){<br>        LL num=0;<br>        for(int i=0;i&lt;BIT;++i){<br>            num+=(sum[rt][i]&lt;&lt;i);<br>        }<br>        num+=p;<br>        for(int i=0;i&lt;BIT;++i){<br>            sum[rt][i]=(num&gt;&gt;i)&amp;1;<br>        }<br>        return;<br>    }<br>    pushdown(l,r,rt);<br>    int m=(l+r)&gt;&gt;1;<br>    if(x&lt;=m) update_add(x,p,lson);<br>    else    update_add(x,p,rson);<br>    pushup(rt);<br>}</p>
<p>void update_xor(int L,int R,LL c,int l,int r,int rt){<br>    if(L&lt;=l&amp;&amp;r&lt;=R){<br>        for(int i=0;i&lt;BIT;++i){<br>            sum[rt][i]=((c&gt;&gt;i)&amp;1)?((r-l+1)-sum[rt][i]):(sum[rt][i]);<br>            lazy[rt][i]^=((c&gt;&gt;i)&amp;1);<br>        }<br>        return;<br>    }<br>    pushdown(l,r,rt);<br>    int m=(l+r)&gt;&gt;1;<br>    if(L&lt;=m) update_xor(L,R,c,lson);<br>    if(R&gt;m)   update_xor(L,R,c,rson);<br>    pushup(rt);<br>}</p>
<p>LL query(int L,int R,int l,int r,int rt){<br>    LL ret=0;<br>    if(L&lt;=l&amp;&amp;r&lt;=R){<br>        for(int i=0;i&lt;BIT;++i){<br>            ret+=(sum[rt][i]&lt;&lt;i);<br>        }<br>        return ret;<br>    }</p>
<pre><code>pushdown(l,r,rt);
int m=(l+r)&amp;gt;&amp;gt;1;
if(L&amp;lt;=m) ret+=query(L,R,lson);
if(R&amp;gt;m)   ret+=query(L,R,rson);
pushup(rt);
return ret;
</code></pre><p>}</p>
<p>int main(){<br>    //freopen(“C:\Users\F\Desktop\in.txt”, “r”, stdin);<br>    //freopen(“C:\Users\F\Desktop\out.txt”, “w”, stdout);<br>    int T;<br>    int n,q;<br>    int a,b,k;<br>    int op;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d”,&amp;n,&amp;q);<br>        build(1,n,1);<br>        while(q–){<br>            scanf(“%d%d%d”,&amp;op,&amp;a,&amp;b);<br>            if(op==1){<br>                update_add(a,b,1,n,1);<br>            }else if(op==2){<br>                scanf(“%d”,&amp;k);<br>                update_xor(a,b,k,1,n,1);<br>            }else if(op==3){<br>                printf(“%lld\n”,query(a,b,1,n,1));<br>            }<br>        }<br>    }<br>    return 0;<br>}<br><br>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>这道题没什么难度，就是拼模板。。。</p>
<p>通过运用简单的排列组合知识可以推出公式$$ans=(K^L\times C_{L}^{M}\times (K-1)^M / 2) \ mod \ N$$</p>
<p>因为K或者K-1必有一个为偶数，所以不用求逆元</p>
<p>难点就在于$$C_{L}^{M} \ mod \ N$$</p>
<p>因为N不一定为素数，就可以把它分解为$$N=\prod <em>{i=1}^{k} p</em>{i}^{t_i},(k=1,2,3…)$$的形式，$$p_i$$为素数</p>
<p>可以求出所有的$$C<em>{L}^{M} \ mod \ p</em>{i}^{t_i}$$，再用中国剩余定理合并</p>
<p>至于求$$C<em>{L}^{M} \ mod \ p</em>{i}^{t_i}$$，可以直接用lucas的模板解出</p>
<p>&nbsp;</p>
<p>标程：</p>
<p><pre class="lang:c++ decode:true ">#include&lt;cstdio&gt;</pre></p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cstring&gt;<br>using namespace std;</p>
<p>#define pb push_back</p>
<p>#define LL long long</p>
<p>#define INF 1&lt;&lt;30</p>
<p>LL N,K,L,M;</p>
<p>LL POW(LL a,LL b,LL mod)<br>{<br>    LL ans=1;<br>    while(b)<br>    {<br>        if(b&amp;1) ans=ans<em>a%mod;<br>        a=a</em>a%mod;<br>        b&gt;&gt;=1;<br>    }<br>    return ans;<br>}</p>
<p>LL POW(LL a,LL b)<br>{<br>    LL ans=1;<br>    while(b)<br>    {<br>        if(b&amp;1) ans=ans<em>a;<br>        a=a</em>a;<br>        b&gt;&gt;=1;<br>    }<br>    return ans;<br>}</p>
<p>LL extend_gcd(LL a,LL b,LL &amp;x,LL &amp;y) {<br>    if(a==0&amp;&amp;b==0) return -1;<br>    if(b==0) {<br>        x=1;<br>        y=0;<br>        return a;<br>    }<br>    LL d=extend_gcd(b,a%b,y,x);<br>    y-=a/b*x;<br>    return d;<br>}</p>
<p>bool modular(LL a[],LL m[],LL k)<br>{<br>    LL d,t,c,x,y,i;</p>
<pre><code>for(i=2;i&amp;lt;=k;i++)
{
    d=extend_gcd(m[1],m[i],x,y);
    c=a[i]-a[1];
    if(c%d) return false;
    t=m[i]/d;
    x=(c/d*x%t+t)%t;
    a[1]=m[1]*x+a[1];
    m[1]=m[1]*m[i]/d;
}
return true;
</code></pre><p>}</p>
<p>LL inv(LL a,LL n) {<br>    LL x,y;<br>    LL d=extend_gcd(a,n,x,y);<br>    if(d==1) return (x%n+n)%n;<br>    else return -1;<br>}</p>
<p>LL C(LL n,LL m,LL mod)<br>{<br>    if(m&gt;n) return 0;<br>    LL ans=1,i,a,b;<br>    for(i=1;i&lt;=m;i++)<br>    {<br>        a=(n+1-i)%mod;<br>        b=inv(i%mod,mod);<br>        ans=ans<em>a%mod</em>b%mod;<br>    }<br>    return ans;<br>}</p>
<p>LL C1(LL n,LL m,LL mod)<br>{<br>    if(m==0) return 1;<br>    return C(n%mod,m%mod,mod)*C1(n/mod,m/mod,mod)%mod;<br>}</p>
<p>LL cal(LL n,LL p,LL t)<br>{<br>    if(!n) return 1;<br>    LL x=POW(p,t),i,y=n/x,temp=1;<br>    for(i=1;i&lt;=x;i++) if(i%p) temp=temp<em>i%x;<br>    LL ans=POW(temp,y,x);<br>    for(i=y</em>x+1;i&lt;=n;i++) if(i%p) ans=ans<em>i%x;<br>    return ans</em>cal(n/p,p,t)%x;<br>}</p>
<p>LL C2(LL n,LL m,LL p,LL t)<br>{<br>    LL x=POW(p,t);<br>    LL a,b,c,ap=0,bp=0,cp=0,temp;<br>    for(temp=n;temp;temp/=p) ap+=temp/p;<br>    for(temp=m;temp;temp/=p) bp+=temp/p;<br>    for(temp=n-m;temp;temp/=p) cp+=temp/p;<br>    ap=ap-bp-cp;<br>    LL ans=POW(p,ap,x);<br>    a=cal(n,p,t);<br>    b=cal(m,p,t);<br>    c=cal(n-m,p,t);<br>    ans=ans<em>a%x</em>inv(b,x)%x*inv(c,x)%x;<br>    return ans;<br>}</p>
<p>//C(n,m)%mod<br>LL Lucas(LL n,LL m,LL mod)<br>{<br>    LL i,t,cnt=0;<br>    LL A[205],M[205];<br>    for(i=2;i*i&lt;=mod;i++) if(mod%i==0)<br>    {<br>        t=0;<br>        while(mod%i==0)<br>        {<br>            t++;<br>            mod/=i;<br>        }<br>        M[++cnt]=POW(i,t);<br>        if(t==1) A[cnt]=C1(n,m,i);<br>        else A[cnt]=C2(n,m,i,t);<br>    }<br>    if(mod&gt;1)<br>    {<br>        M[++cnt]=mod;<br>        A[cnt]=C1(n,m,mod);<br>    }<br>    modular(A,M,cnt);<br>    return A[1];<br>}</p>
<p>LL solve()<br>{<br>    if(!M) return POW(K,L,N)+1;<br>    LL ans=1;<br>    if(K&amp;1) ans=ans<em>POW(K,L,N)</em>(K-1)/2%N<em>POW(K-1,M-1,N)%N;<br>    else ans=ans</em>POW(K-1,M,N)<em>K/2%N</em>POW(K,L-1,N)%N;<br>    ans=ans*Lucas(L,M,N)%N;<br>    return ans+1;<br>}</p>
<p>int main()<br>{<br>    //freopen(“C:\Users\F\Desktop\in.txt”, “r”, stdin);<br>    //freopen(“C:\Users\F\Desktop\out.txt”, “w”, stdout);<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–)<br>    {<br>        scanf(“%lld%lld%lld%lld”,&amp;N,&amp;L,&amp;K,&amp;M);<br>        printf(“%lld\n”,solve());<br>    }<br>    return 0;<br>}<br><br>&nbsp;</p>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#镜像翻转"><span class="toc-nav-text">镜像翻转</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#字符矩阵"><span class="toc-nav-text">字符矩阵</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#数组变换"><span class="toc-nav-text">数组变换</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#模板题"><span class="toc-nav-text">模板题</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://qinshaoxuan.com/articles/805.html';
    var banner = ''
    if (banner !== 'undefined') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "yanm1ng";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "2015年计算机学院程序设计大赛结果及题解",
        owner: "yanm1ng",
        repo: "yanm1ng.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2017 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="../js/script.js"></script>
  </body>
</html>