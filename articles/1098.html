<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="../css/images/logo.png">
  
  <title>
    
      《深入理解Java虚拟机》学习笔记（5）——类加载机制 | Xuan&#39;s Blog
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="../js/qrious.js"></script>
<script src="../js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="../index.html">
      <div class="logo"></div>
      <span>Xuan's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="../index.html" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="../index.html" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>《深入理解Java虚拟机》学习笔记（5）——类加载机制</h2>
  <p class="post-date">2016-04-30</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><blockquote>
<p>资料总结自：《深入理解Java虚拟机》 周志明 著</p>
</blockquote>
<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）</strong>7个阶段。其中<strong>验证、准备、解析3个部分统称为链接（Linking）</strong>。</p>
<p>这7个阶段的发生顺序如下图：</p>
<p><img src="http://qsxuan.com/wp-content/uploads/2016/04/jvm-7-1.png" alt="jvm-7-1"></p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序使确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后才开始，这是为了支持Java语言的运行时绑定。而且这些阶段也并不是前一个阶段结束才开始下一阶段，而是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用激活另一个阶段。</p>
<p>&nbsp;</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载（Loading）是类加载（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。<br>虚拟机规范的这3点要求并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如第一条，它并没有指明要从哪里获取、怎样获取。虚拟机设计团队在加载阶段搭建了一个相当开发的平台，Java发展历程中，充满创造力的开发人员则在这个平台上玩出了各种花样，许多Java技术都建立在这一基础上，例如：</li>
</ol>
<ul>
<li>从ZIP包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。</li>
<li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分法。</li>
<li>……<br>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需要的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。</li>
</ul>
<p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<p>&nbsp;</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>前面已经说过，Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生Class文件。如果虚拟机不检查输入的字节流，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>
<p>从整体上看，验证阶段大致会完成下面4个阶段的检验动作：</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<h3 id="1-文件格式验证"><a href="#1-文件格式验证" class="headerlink" title="1. 文件格式验证"></a>1. 文件格式验证</h3><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数 0xCAFEBABE 开头。</li>
<li>主、次版本号是否在当前虚拟机处理范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
<li>……<br>上面只是验证的一小部分，该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这一阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</li>
</ul>
<h3 id="2-元数据验证"><a href="#2-元数据验证" class="headerlink" title="2. 元数据验证"></a>2. 元数据验证</h3><p>第二阶段是对字节描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li>
<li>……<br>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</li>
</ul>
<h3 id="3-字节码验证"><a href="#3-字节码验证" class="headerlink" title="3. 字节码验证"></a>3. 字节码验证</h3><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的时间，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来载入本地变量表中。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
<li>……<br>如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。这里涉及了离散数学中一个很著名的问题“Halting Problem”：通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</li>
</ul>
<h3 id="4-符号引用验证"><a href="#4-符号引用验证" class="headerlink" title="4. 符号引用验证"></a>4. 符号引用验证</h3><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在链接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在制定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li>
<li>……<br>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</li>
</ul>
<p>&nbsp;</p>
<blockquote>
<p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不一定是必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用</p>
<p><span class="lang:c++ decode:true  crayon-inline">-Xverify:none</span>  参数来关闭大部分的类验证措施，以缩短虚拟机类加载得时间。<br>&nbsp;</p>
</blockquote>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>这时候进行内存的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>
<pre class="toolbar:2 lang:java decode:true">public static int value = 123;</pre>
那变量<span class="lang:c++ decode:true  crayon-inline ">value</span> 在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把<span class="lang:java decode:true crayon-inline">value</span> 赋值为123的putstatic指令是程序被编译后，存放于类构造器<span class="lang:java decode:true crayon-inline">&lt;clinit&gt;()</span> 方法之中，所以把<span class="lang:java decode:true crayon-inline ">value</span> 赋值为123的动作将在初始化阶段才会执行。

下面列出了Java中所有基本数据类型的零值：
<table class="table">
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>'\u0000'</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody>
</table>
上面提到，在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值<span class="lang:java decode:true crayon-inline">value</span> 就会被初始化为ConstantValue属性所指的的值，假设上面类变量<span class="lang:java decode:true crayon-inline">value</span> 的定义变为：
<pre class="toolbar:2 lang:java decode:true">public static final int value = 123;</pre>
编译时Javac将会为<span class="lang:java decode:true crayon-inline">value</span> 生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue对的设置将<span class="lang:java decode:true crayon-inline">value</span> 赋值为123。

&nbsp;

## 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
> *   符号引用（Symbolic Refrences）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以不相同，但它们能接受的符号引用必须一致，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
> *   直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。
虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。下面列出前面4种引用的解析过程。

### 1\. 类或接口的解析

假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：

1.  如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，有可能出发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。
2.  如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符回事类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
3.  如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还需要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。

### 2\. 字段解析

要解析一个未被解析过的字段符号引用，首先会对字段所属的类或者接口的符号引用进行解析。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。

1.  如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
2.  否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父类接口，如果接口中包含了简单名称和字段描述都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3.  否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4.  否则，查找失败，抛出java.lang.NoSuchFieldError异常。
如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。

### 3\. 类方法解析

类方法解析的第一个步骤与字段解析一样，也需要先解析方法所属的类或接口的符号引用。如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。

1.  类方法和接口方法符号引用的常量类型定义是分开的，如果发现C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。
2.  如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3.  否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4.  否则，在类C实现的接口列表及它们的父类接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。
5.  否则，宣告方法查找失败，抛出java.lang.NoSuchFieldError异常。
最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。

### 4\. 接口方法解析

接口方法也需要先解析出方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。

1.  与类方法解析不同，如果发现C是个类而不接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。
2.  否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3.  否则，在接口C的父接口中递归查找，知道java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4.  否则，宣告方法查找失败，抛出java.lang.IllegalAccessError异常。
由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。

&nbsp;

## 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才开始执行类中定义的Java程序代码（或者说是字节码）。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<span class="lang:java decode:true crayon-inline">&lt;clinit&gt;()</span> 方法的过程。

*   <span class="lang:java decode:true crayon-inline">&lt;clinit&gt;()</span> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（<span class="lang:java decode:true  crayon-inline ">static{}</span> 块）中的语句合并产生的，编译器收集的顺序使由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，当时不能访问，如下面代码中的例子
<pre class="lang:java decode:true">public class Test {
    static{
        i=0;                    //给变量赋值可以正常编译通过
        System.out.println(i);    //这句编译器会提示“Cannot reference a field before it is defined”
    }
    static int i = 1;
}</pre>

<ul>
<li><span class="lang:java decode:true crayon-inline">&lt;clinit&gt;()</span> 方法与类的构造函数（或者说实例构造器<span class="lang:java decode:true crayon-inline">&lt;init&gt;()</span> 方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法执行之前，父类的<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法已经执行完毕。因此在虚拟机中第一个被执行的<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法的类肯定是java.lang.Object。</li>
<li><p>由于父类的<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下面代码中，字段<span class="lang:java decode:true  crayon-inline ">B</span> 的值将会是2而不是1。</p>
<pre class="lang:java decode:true">public class Test {
static class Parent{
    public static int A=1;
    static {
        A=2;
    }
}
static class Sub extends Parent{
    public static int B=A;
}
public static void main(String[] args) {
    System.out.println(Sub.B);                //输出：2
}
}</pre>
</li>
<li><p><span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法。</p>
</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法。但接口与类不同的是，执行接口的<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法不需要先执行父接口的<span class="lang:java decode:true crayon-inline">&lt;clinit&gt;()</span> 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法。</li>
<li><p>虚拟机会保证一个类的<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法，其他线程都需要阻塞等待，直到活动线程执行<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法完毕。如果在一个类的<span class="lang:java decode:true crayon-inline ">&lt;clinit&gt;()</span> 方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的，下面代码演示了这种场景。<br><pre class="lang:java decode:true">public class Test {<br>static class DeadLoopClass {</pre></p>
<pre><code>static {
    if (true) {
        System.out.println(Thread.currentThread() + &quot;init DeadLoopClass&quot;);
        while (true) {

        }
    }
}
</code></pre><p>}</p>
<p>public static void main(String[] args) {</p>
<pre><code>Runnable script = new Runnable() {

    @Override
    public void run() {
        System.out.println(Thread.currentThread() + &quot;start&quot;);
        DeadLoopClass dlc = new DeadLoopClass();
        System.out.println(Thread.currentThread() + &quot;run over&quot;);

    }
};

Thread thread1 = new Thread(script);
Thread thread2 = new Thread(script);
thread1.start();
thread2.start();
</code></pre><p>}<br>}<br>运行结果如下，即一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待。<br><pre class="toolbar:2 lang:default decode:true">Thread[Thread-0,5,main]start<br>Thread[Thread-1,5,main]start<br>Thread[Thread-0,5,main]init DeadLoopClass<br></pre><br>&nbsp;</p>
</li>
</ul>
<p>对于初始化阶段，虚拟机规范严格规定了有且只有5种情况必须进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先出发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包括<span class="lang:java decode:true  crayon-inline ">main()</span> 方法的那个类），虚拟机会先初始化这个类。</li>
<li><p>当使用JDK 1.7的动态于洋支持时，如果一个java.lang.invoke.MethodHandle实例后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。<br>这5种场景中的行为成为对一个类进行主动引用。除此之外，所有引用类的方法都不会触发初始化，成为被动引用。<br><pre class="lang:java decode:true">/**</pre></p>
<ul>
<li>被动使用类字段演示一： </li>
<li>通过子类引用父类的静态字段，不会导致子类初始化<br>*/<br>class SuperClass {<br>static {<br>  System.out.println(“SuperClass init!”);<br>}</li>
</ul>
<p>public static int value = 123;<br>}</p>
</li>
</ol>
<p>class SubClass extends SuperClass {<br>    static {<br>        System.out.println(“SubClass init!”);<br>    }<br>}</p>
<p>/**</p>
<ul>
<li>非主动使用类字段演示<br>*/<br>public class NotInitialization {<br> public static void main(String[] args) {<pre><code>System.out.println(SubClass.value);
</code></pre> }<br>}</li>
</ul>
<p>/*</p>
<ul>
<li>输出结果：</li>
<li>SuperClass init!</li>
<li>123</li>
<li><em>/<br>上述代码运行后，只会输出“SuperClass init!”，而不会输出“SubClass init!”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会出发父类的初始化而不会触发子类的初始化。至于是否要被出发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于HotSpot虚拟机来说，可通过<span class="lang:java decode:true  crayon-inline ">-XX:+TraceClassLoading</span> 参数观察到此操作会导致子类的加载。<br><pre class="lang:java decode:true ">/*</pre></em></li>
<li>被动使用类字段演示二： </li>
<li><p>通过数组定义来引用类，不会触发此类的初始化<br>*/<br>class SuperClass {<br> static {</p>
<pre><code>System.out.println(&quot;SuperClass init!&quot;);
</code></pre><p> }</p>
<p> public static int value = 123;<br>}</p>
</li>
</ul>
<p>class SubClass extends SuperClass {<br>    static {<br>        System.out.println(“SubClass init!”);<br>    }<br>}</p>
<p>public class NotInitialization {<br>    public static void main(String[] args) {<br>        SuperClass[] sca = new SuperClass[10];<br>    }<br>}</p>
<p>/*</p>
<ul>
<li>输出结果：</li>
<li>*/<br>上述代码运行后，并没输出“SuperClass init!”，说明并没有出发类SuperClass的初始化阶段。但是这段代码里面触发了另外一个名为“[SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。</li>
</ul>
<p>这个类代表了一个元素类型为SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用只有被修饰为public的<span class="lang:java decode:true  crayon-inline ">length</span> 属性和<span class="lang:java decode:true  crayon-inline ">clone()</span> 方法）都实现在这个类里。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法，而C/C++直接翻译为对数组指针的移动。在Java语言中，当检查到发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常。</p>
<p><pre class="lang:java decode:true">/**</pre></p>
<ul>
<li>被动使用类字段演示三： </li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，</li>
<li><p>因此不会触发定义常量的类的初始化。<br>*/<br>class ConstClass {<br> static {</p>
<pre><code>System.out.println(&quot;ConstClass init!&quot;);
</code></pre><p> }</p>
<p> public static final String HELLOWORLD = “hello world”;<br>}</p>
</li>
</ul>
<p>public class NotInitialization {<br>    public static void main(String[] args) {<br>        System.out.println(ConstClass.HELLOWORLD);<br>    }<br>}</p>
<p>/*</p>
<ul>
<li>输出结果：</li>
<li>hello world</li>
<li>*/<br>上述代码运行之后，也没有输出“ConstClass init!”，只是因为虽然在Java源码中引用了ConstClass类中的常量<span class="lang:java decode:true  crayon-inline ">HELLOWORLD</span> ，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类对自身常量池的引用了，也就是说，实际上NotInitialization 的Class文件之中并没有ConstClass的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。</li>
</ul>
<p>接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程。接口与类有所区别的是前面讲述的5种需要初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到了父接口的时候（如引用接口中定义的常量）才会初始化。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="../tags#JVM" >
    <span class="tag-code">JVM</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#加载"><span class="toc-nav-text">加载</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#验证"><span class="toc-nav-text">验证</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-文件格式验证"><span class="toc-nav-text">1. 文件格式验证</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-元数据验证"><span class="toc-nav-text">2. 元数据验证</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-字节码验证"><span class="toc-nav-text">3. 字节码验证</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-符号引用验证"><span class="toc-nav-text">4. 符号引用验证</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#准备"><span class="toc-nav-text">准备</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://qinshaoxuan.com/articles/1098.html';
    var banner = ''
    if (banner !== 'undefined') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "yanm1ng";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "《深入理解Java虚拟机》学习笔记（5）——类加载机制",
        owner: "yanm1ng",
        repo: "yanm1ng.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2017 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="../js/script.js"></script>
  </body>
</html>