<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="../css/images/logo.png">
  
  <title>
    
      《深入理解Java虚拟机》学习笔记（1）——JVM垃圾回收与内存分配策略 | Xuan&#39;s Blog
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="../js/qrious.js"></script>
<script src="../js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="../index.html">
      <div class="logo"></div>
      <span>Xuan's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="../index.html" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="../about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="../index.html" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="../about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>《深入理解Java虚拟机》学习笔记（1）——JVM垃圾回收与内存分配策略</h2>
  <p class="post-date">2016-04-21</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><blockquote>
<p>资料总结自：《深入理解Java虚拟机》 周志明 著</p>
</blockquote>
<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><p>堆中几乎放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。</p>
<p>客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下他都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（Component Object Model）技术、使用ActionScript3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛引用的Squirrel中都是用了引用计数算法进行内存管理。但是Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。</p>
<p>举个简单的例子，下面代码中：对象objA和objB都有字段instance，赋值令objA.instance = objB及objB.instance = objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是他们因为互相引用着对方，导致他们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。</p>
<p><pre class="lang:java decode:true">/**</pre></p>
<ul>
<li>VM arguments : -verbose:gc -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:SurvivorRatio=8</li>
<li><p>@author F<br>*/<br>public class ReferenceCountingGC {</p>
<p> public Object instence = null;</p>
<p> private static final int _1MB = 1024 * 1024;</p>
<p> /**</p>
<ul>
<li><p>这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过<br><em>/<br>private byte[] bigSize = new byte[2 </em> _1MB];</p>
<p>public static void main(String[] args) {<br> ReferenceCountingGC objA = new ReferenceCountingGC();<br> ReferenceCountingGC objB = new ReferenceCountingGC();<br> objA.instence = objB;<br> objB.instence = objA;</p>
<p> objA = null;<br> objB = null;</p>
<p> // 假设在这行发生GC，那么objA和objB是否能被回收？<br> System.gc();<br>}<br>}<br>GC日志：<br><pre class="wrap:true lang:default mark:1 decode:true">[GC (System.gc()) [PSYoungGen: 5408K-&gt;504K(6144K)] 5408K-&gt;836K(19968K), 0.0007061 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (System.gc()) [PSYoungGen: 504K-&gt;0K(6144K)] [ParOldGen: 332K-&gt;683K(13824K)] 836K-&gt;683K(19968K), [Metaspace: 2804K-&gt;2804K(1056768K)], 0.0052888 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]<br>Heap<br>PSYoungGen      total 6144K, used 37K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)<br>eden space 5632K, 0% used [0x00000000ff980000,0x00000000ff9897a0,0x00000000fff00000)<br>from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)<br>to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)<br>ParOldGen       total 13824K, used 683K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)<br>object space 13824K, 4% used [0x00000000fec00000,0x00000000fecaae68,0x00000000ff980000)<br>Metaspace       used 2810K, capacity 4486K, committed 4864K, reserved 1056768K<br>class space    used 307K, capacity 386K, committed 512K, reserved 1048576K<br></pre><br>从运行结果中可以清楚的看到GC日志中第一行包含“5408K-&gt;836K”，以为着虚拟机并没有因为这两个对象互相引用就不回收他们，这也从侧面说明<strong>虚拟机并不是通过引用计数算法来判断对象是否存活的</strong>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>在主流的商用程序语言（Java、C#）的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路就是通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达）时，则证明这个对象是不可用的。</p>
<p>如下图：</p>
<p><img src="http://qsxuan.com/wp-content/uploads/2016/04/jvm-3-1.png" alt="jvm-3-1"></p>
<p>对象object 5、object 6、object 7虽然相互有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为可回收的对象。</p>
<p>&nbsp;</p>
<p>在Java语言里，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中的常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）的引用的对象。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h3><p>最基础的收集算法时“标记—清除”（Mark-Sweep）算法，算法分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p>
<p>之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p>
<p>它的主要缺点有两个：</p>
<ul>
<li>一个是效率问题，标记和清除过程的效率都不高。</li>
<li>另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致：当程序在以后的运行过程中需要分配较大对象时无法找到猪狗的连续内存而不得不提前出发另一次垃圾收集动作。</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，一种被称为“复制”（Copying）的收集算法出现了，他将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p>只是这种算法的代价是讲内存缩小为原来的一般，未免太高了一点。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。</p>
<p>当回收时，将Eden和Survivor中还活着的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。</p>
<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8：1</p>
<p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活， 当Survivor空间不够用时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）。</p>
<h3 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h3><p>标记过程仍然与“标记—清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>而老年带中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或“标记—整理”算法来进行回收。</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象的内存分配，往大方向上讲，就是在堆上分配（但也可能进过JIT编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<p>下面说明的内存分配和回收的策略是在使用Serial/Serial Old收集器的环境下。</p>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>下面代码中，尝试分配3个2MB大小和1个4MB大小的对象，在运行时通过-Xms20M、-Xmx20M和-Xmn10M这三个参数限制Java堆大小为20MB，且不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。-XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8比1。</p>
<p><pre class="lang:java decode:true ">/**</pre></p>
<ul>
<li>VM arguments : -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</li>
<li><ul>
<li>@author F<br><em>/<br>public class testAllocation {<br>private static final int _1MB = 1024 </em> 1024;</li>
</ul>
<p>public static void main(String[] args) {</p>
<pre><code>byte[] allocation1, allocation2, allocation3, allocation4;
allocation1 = new byte[2 * _1MB];
allocation2 = new byte[2 * _1MB];
allocation3 = new byte[2 * _1MB];
allocation4 = new byte[4 * _1MB]; // 出现一次Minor GC
</code></pre><p>}<br>}<br>GC日志<br><pre class="wrap:true lang:default mark:1,4,8 decode:true">[GC (Allocation Failure) [DefNew: 7619K-&gt;684K(9216K), 0.0034349 secs] 7619K-&gt;6828K(19456K), 0.0034738 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br>def new generation   total 9216K, used 4835K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)<br>eden space 8192K,  50% used [0x00000000fec00000, 0x00000000ff00dbf8, 0x00000000ff400000)<br>from space 1024K,  66% used [0x00000000ff500000, 0x00000000ff5ab290, 0x00000000ff600000)<br>to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)<br>tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)<br>the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)<br>Metaspace       used 2810K, capacity 4486K, committed 4864K, reserved 1056768K<br>class space    used 307K, capacity 386K, committed 512K, reserved 1048576K</pre><br>执行代码中分配allocation4对象的语句时会发生一次Minor GC，这次GC的结果是新生代7619K-&gt;684K，而总内存占用量则几乎没有减少（7619K-&gt;6828K，因为allocation1、2、3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。</p>
</li>
</ul>
<p>这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。</p>
<p>这次GC结束后，4MB的allocation4对象被顺利的分配在Eden中，因此程序执行完的结果是Eden占用4MB（被allocation4占用），Survivor空闲，老年代被占用6MB（被allocation1、2、3占用）。通过GC日志可以证实这一点。</p>
<blockquote>
<ul>
<li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li>
<li>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
</blockquote>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息（写程序应当避免写“短命的”大对象），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间产生大量的内存复制。</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。</p>
<p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当他的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。</p>
<p>对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="../tags#JVM" >
    <span class="tag-code">JVM</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#对象已死？"><span class="toc-nav-text">对象已死？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#引用计数算法"><span class="toc-nav-text">引用计数算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#可达性分析算法"><span class="toc-nav-text">可达性分析算法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#垃圾收集算法"><span class="toc-nav-text">垃圾收集算法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#标记—清除算法"><span class="toc-nav-text">标记—清除算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#复制算法"><span class="toc-nav-text">复制算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#标记—整理算法"><span class="toc-nav-text">标记—整理算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#分代收集算法"><span class="toc-nav-text">分代收集算法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#内存分配与回收策略"><span class="toc-nav-text">内存分配与回收策略</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#对象优先在Eden分配"><span class="toc-nav-text">对象优先在Eden分配</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#大对象直接进入老年代"><span class="toc-nav-text">大对象直接进入老年代</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#长期存活的对象将进入老年代"><span class="toc-nav-text">长期存活的对象将进入老年代</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#动态对象年龄判定"><span class="toc-nav-text">动态对象年龄判定</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#空间分配担保"><span class="toc-nav-text">空间分配担保</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://qinshaoxuan.com/articles/1014.html';
    var banner = ''
    if (banner !== 'undefined') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "yanm1ng";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "《深入理解Java虚拟机》学习笔记（1）——JVM垃圾回收与内存分配策略",
        owner: "yanm1ng",
        repo: "yanm1ng.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2017 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="../js/script.js"></script>
  </body>
</html>