---
title: 正则表达式基础
tags:
  - 正则表达式
url: 1522.html
id: 1522
categories:
  - 工具
date: 2016-10-15 18:37:45
TOC: true
summary: 正则表达式就是用某种模式去匹配一类字符串的一种公式。简单记录一下正则表达式的规则。
---

正则表达式就是用某种模式去匹配一类字符串的一种公式。简单记录一下正则表达式的规则。

  

# 元字符


| 元字符   | 描述                         |
| :------- | ---------------------------- |
| .        | 匹配除换行符意外的任意字符   |
| \w       | 匹配字母或数字或下划线或汉字 |
| \s       | 匹配任意空白符               |
| \d       | 匹配数字                     |
| \b       | 匹配单词的开始或结束         |
| ^        | 匹配字符串的开始             |
| $        | 匹配字符串的结束             |
| -        | 表示范围                     |
| []       | 匹配括号中的任意一个字符     |
| ()       | 分组                         |
| &verbar; | 分支                         |
| \* + ? {} | 量词                         |

 

# 量词


| 限定代码/语法 | 描述            |
| ------------- | --------------- |
| \*             | 重复0次或更多次 |
| +             | 重复1次或更多次 |
| ?             | 重复0次或1次    |
| {n}           | 重复n次         |
| {n,}          | 重复n次或更多次 |
| {n,m}         | 重复n到m次      |

 

# 匹配规则


## 字符组

`[]` 匹配括号中的任意一个字符

` [aeiou]` 匹配任何一个英文元音字母

` c[aou]t` 匹配“cat”、“cot”、“cut”这三个单词，而“caout”则不匹配

` [0-9]` 匹配一位数字，等同于`\d `



## 转义

需要匹配元字符本身时，使用 `\` 转义 

`\.` 匹配“.”  



## 反义

| 常用反义   | 描述                                       |
| ---------- | ------------------------------------------ |
| \W         | 匹配任意不是字母或数字或下划线或汉字的字符 |
| \\S        | 匹配任意不是任意空白符的字符               |
| \\D        | 匹配任意非数字的字符                       |
| \\B        | 匹配不是单词的开始或结束的位置             |
| \[^aeiou\] | 匹配除了aeiou这几个字母以外的任意字符      |



## 分支

`|` 表示分支，即可能存在的多钟情况

` aa|bb` 匹配“aa”、“bb”，但不匹配“aabb”。  



## 分组

`()` 可用来分组，简单的用法是表示一个整体。

` (c|to)at` 匹配“cat”、“toat”。

 其他用法如下表：


{% raw %}
<table>
    <thead>
        <tr>
            <th>类别</th>
            <th>代码 / 语法</th>
            <th>描述</th></tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="3">捕获</td>
            <td>(exp)</td>
            <td>匹配 exp，并捕获文本到自动命名的组里</td></tr>
        <tr>
            <td>(?&lt;name&gt;exp)/(?'name'exp)</td>
            <td>匹配 exp，并捕获文本到名称为 name 的组里</td></tr>
        <tr>
            <td>(?:exp)</td>
            <td>匹配 exp，不捕获匹配的文本，也不给此分组分配组号</td></tr>
        <tr>
            <td rowspan="4">零宽断言</td>
            <td>(?=exp)</td>
            <td>匹配 exp 前面的位置</td></tr>
        <tr>
            <td>(?&lt;=exp)</td>
            <td>匹配 exp 后面的位置</td></tr>
        <tr>
            <td>(?!exp)</td>
            <td>匹配后面跟的不是 exp 的位置</td></tr>
        <tr>
            <td>(?&lt;!exp)</td>
            <td>匹配前面不是 exp 的位置</td></tr>
        <tr>
            <td>注释</td>
            <td>(?#comment)</td>
            <td>提供注释辅助阅读，不对正则表达式产生任何影响</td></tr>
    </tbody>
</table>
{% endraw %} 



## 反向引用

反向引用用于重复搜索前面某个分组匹配的文本

` \b(\w+)\b\s+\1\b` 匹配重复的单词，如“go go”。其中`\1`表示分组1中捕获的内容，即`(\w+)` 

` \b(?<word>\w+)\b\s+\k<word>\b` 或`\b(?<word>\w+)\b\s+\k'word'\b` 也可  



## 环视

断言用来声明一个应该为真的事实。正则表达式中，只有当断言为真时才会继续进行匹配。**断言匹配的是一个事实，而不是内容。**这里说的4个断言，用于查找在某些内容（但并不包括这些内容）之前或之后，也就是一个位置应该满足的一定条件（即断言），因此也称为零宽断言。



**1. 顺序肯定环视 (?=exp)**

断言自身出现位置的后面能匹配表达式exp

`\b\w+(?=ing\b)` 匹配“I'm <span style="background-color: #81d4fa;">sing</span>ing while you're <span style="background-color: #81d4fa;">danc</span>ing.”，即以ing结尾的单词前半部分   



**2. 逆序肯定环视 (?<=exp)** 

断言自身出现位置的前面能匹配表达式exp

` (?<=\bre)\w+\b ` 匹配“re<span style="background-color: #81d4fa;">ading</span> a book”，即以re开头的单词后半部分

`(?<=\s)\d+(?=\s)` 匹配“ <span style="background-color: #81d4fa;">123</span> <span style="background-color: #81d4fa;">456</span> <span style="background-color: #81d4fa;">789</span> ”，即被空白符隔开的数字

`(?<=<(\w+)>).\*(?=<\/\1>)` 匹配“<h1\><span style="background-color: #81d4fa;">123</span><h1\>”



**3. 顺序否定环视 (?!exp)**

断言自身出现位置的后面不能匹配表达式exp 

`\d{3}(?!\d)` 匹配“1<span style="background-color: #81d4fa;">234</span>abc”，即3位数字后面不能是数字 

`\b((?!abc)\w)+\b` 匹配“aabc <span style="background-color: #81d4fa;">efghi</span>”，即不包含连续字符abc的单词 

`^(?:(?!cat).)+$` 匹配任意位置都不出现“cat”的字符串   



**4. 逆序否定环视 (?<\!exp)**

断言自身出现位置的前面不能匹配表达式exp

` (?<!\[a-z\])\d{7}` 匹配“a1<span style="background-color: #81d4fa;">2312312</span>3”，即前面不是小写字母的7位数字




## 贪婪/懒惰匹配

当正则表达式中包含能接受重复的限定符时，通常的行为是匹配尽可能多的字符。即默认为贪婪匹配。 有时需要匹配尽可能少的字符，也就是懒惰匹配。只需要在量词后面加一个问号。 

`a.*b` 匹配“<span style="background-color: #81d4fa;">aabab</span>”

`a.*?b` 匹配“<span style="background-color: #81d4fa;">aab</span><span style="background-color: #3366ff;">ab</span>”中的两部分



| 懒惰限定符代码/语法 | 描述                            |
| ------------------- | ------------------------------- |
| \*?                 | 重复0次或更多次，但尽可能少重复 |
| +?                  | 重复1次或更多次，但尽可能少重复 |
| ??                  | 重复0次或1次，但尽可能少重复    |
| {n,}?               | 重复n次或更多次，但尽可能少重复 |
| {n,m}?              | 重复n到m次，但尽可能少重复      |

 

# 运算符优先级

优先级从上到下、由高到低排列



| 运算符                              | 描述         |
| ----------------------------------- | ------------ |
| \\                                  | 转义符       |
| () \[\]                             | 括号和中括号 |
| * \+ ? {}                           | 量词         |
| ^ $ \\anyMateCharacter anyCharacter | 定位点和序列 |
| &verbar;                            | 分支         |

 

# 常用模式

可用 `(?model)exp` 开启，只对其后面的字符起作用。php中还可以使用 `%exp%model` 、`/exp/model` 、`#exp#model`



| 修饰符 | 描述                     |
| ------ | ------------------------ |
| i      | 忽略大小写模式           |
| m      | 多行模式                 |
| s      | 点号通配模式             |
| U      | 懒惰模式                 |
| D      | 结尾限制，忽略结尾的换行 |
| u      | 支持 UTF-8 转义表达      |

 

# 常用正则表达式

手机号：`1[358]\d{9}` 

邮箱：`^[a-z0-9_\-]+(\.[a-z0-9_\-]+)*@([a-z0-9_\-]+\.)+\w{2,6}` 

HTML标签：`<\/?[^>]+>` 

QQ：`[1-9]\d{4,9}` 

IP：`(?:(2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}\1` 

日期：`\d{4}-\d{2}-\d{2}`