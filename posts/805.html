
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>xuan&#39;s blog</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xuan,"> 
    
    <meta name="author" content="xuan"> 
    <link rel="alternative" href="atom.xml" title="xuan&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="../img/favicon.ico"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="../css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">2015年计算机学院程序设计大赛结果及题解</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">2015年计算机学院程序设计大赛结果及题解</h1>
        <div class="stuff">
            <span>十二月 21, 2015</span>
            

        </div>
        <div class="content markdown">
            <p>我出的有4道题，其他4道题的题解：h<a href="http://hate13.com/?p=742" target="_blank" rel="noopener">ate13</a></p>
<p><img src="http://qsxuan.com/wp-content/uploads/2015/12/院赛结果.png" alt="院赛结果"></p>
<hr>
<p>&nbsp;</p>
<h2 id="镜像翻转"><a href="#镜像翻转" class="headerlink" title="镜像翻转"></a>镜像翻转</h2><p>可以在纸上推出n=1,2,3的答案，分别为3,8,15，就可以看出规律，$$ans=(n+1)^2-1$$，或者其他的变形</p>
<p>其实题目中第二种跳跃操作的无论颜色是迷惑人的，最短路线就是异色才能跳，因为越过同色之后会出现需要退后的情况，反而浪费了步数。</p>
<p>如果限制只能越过异色的，那么就只有一种走法。那就是先形成红蓝相间的情况，之后就很好走了。</p>
<p>本来之前是准备出小数据让你们能BFS过的，但是自己写了一发，发现n=7的时候都要跑1S（也有可能是我的姿势不对），所以直接改成找规律了。然后强行模了一发QQ号~</p>
<p>&nbsp;</p>
<p>标程：</p>
<p><pre class="lang:c++ decode:true ">#include&lt;cstdio&gt;</pre></p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>#include&lt;cstring&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;string&gt;</p>
<p>#include&lt;map&gt;<br>using namespace std;</p>
<p>#define pb push_back</p>
<p>#define LL long long</p>
<p>#define N 100005</p>
<p>#define INF 1&lt;&lt;30</p>
<p>int main(){<br>    //freopen(“C:\Users\F\Desktop\in.txt”, “r”, stdin);<br>    //freopen(“C:\Users\F\Desktop\out.txt”, “w”, stdout);<br>    LL n;<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%lld”,&amp;n);<br>        printf(“%lld\n”,(((n+1)%459440330)*((n+1)%459440330)-1)%459440330);<br>    }<br>    return 0;<br>}<br><br>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="字符矩阵"><a href="#字符矩阵" class="headerlink" title="字符矩阵"></a>字符矩阵</h2><p>这道题就是考察字符串相关的知识，在我印象中字典树应该是个很基础的东西了。本来预计算法题最有可能被AC的就是这道题，但是结果出乎意料- -</p>
<p>方法很容易想到，就是直接枚举每一个起点，然后开始DFS，只是DFS的时候不能暴力比对每一个字符串，那样对于每一层循环时间都是字符串个数*字符串长度，这样肯定会超时。</p>
<p>之后就会想到一个可以用字典树来优化，DFS向下传递字典树的结点地址，这样就不会重复比对。</p>
<p>而且要注意每次找到一个字符串之后要从字典树里删去，不然也会超时。</p>
<p>&nbsp;</p>
<p>标程：</p>
<p><pre class="lang:c++ decode:true ">#include&lt;cstdio&gt;</pre></p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cstring&gt;<br>using namespace std;</p>
<p>#define pb push_back</p>
<p>#define LL long long</p>
<p>#define INF 1&lt;&lt;30</p>
<p>#define NODE 1000005</p>
<p>#define N 1100</p>
<p>char mpt[N][N];<br>char str[N][N];<br>int vis[N][N];<br>int dir[4][2]={0,1,1,0,0,-1,-1,0};<br>int n,m;</p>
<p>int Next[NODE][26]; //数组建树<br>int cnt[NODE];<br>int val[NODE];<br>int node;</p>
<p>int ans[N];<br>int anscnt=0;</p>
<p>void init() {<br>    node = 1;<br>    memset(Next[0], 0, sizeof(Next[0]));<br>    memset(vis,0,sizeof(vis));<br>    memset(val,0,sizeof(val));<br>    anscnt=0;<br>}</p>
<p>void add(char *s,int id) {<br>    int len = strlen(s);<br>    int cur = 0, p;<br>    for(int i = 0; i &lt; len; ++i) {<br>        p = s[i] -‘a’;<br>        if(Next[cur][p] == 0) {<br>            memset(Next[node], 0, sizeof(Next[node]));<br>            val[node] = 0;<br>            cnt[node]=0;<br>            Next[cur][p] = node++;<br>        }<br>        cnt[Next[cur][p]]++;<br>        cur = Next[cur][p];<br>    }<br>    val[cur]=id;<br>}</p>
<p>void del(char *s){<br>    int len = strlen(s);<br>    int cur = 0, p;<br>    for(int i = 0; i &lt; len; ++i) {<br>        p = s[i] -‘a’;<br>        cnt[Next[cur][p]]–;<br>        cur = Next[cur][p];<br>    }<br>    val[cur]=0;<br>}</p>
<p>bool judge(int x,int y,int cur){<br>    if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)return false;<br>    if(vis[x][y])return false;<br>    if(!cur||!cnt[cur])return false;<br>    return true;<br>}</p>
<p>void dfs(int x,int y,int cur){<br>    if(val[cur]){<br>            ans[anscnt++]=val[cur];<br>            del(str[val[cur]]);<br>    }<br>    for(int i=0;i&lt;4;++i){<br>        int nx=x+dir[i][0];<br>        int ny=y+dir[i][1];<br>        int p = mpt[nx][ny] -‘a’;<br>        if(judge(nx,ny,Next[cur][p])){<br>            vis[nx][ny]=1;<br>            dfs(nx,ny,Next[cur][p]);<br>            vis[nx][ny]=0;<br>        }<br>    }<br>}</p>
<p>int main() {<br>    //freopen(“C:\Users\F\Desktop\in.txt”, “r”, stdin);<br>    //freopen(“C:\Users\F\Desktop\out.txt”, “w”, stdout);</p>
<pre><code>int T;
scanf(&quot;%d&quot;,&amp;amp;T);
while(T--){
    init();
    int q;
    scanf(&quot;%d%d%d&quot;,&amp;amp;n,&amp;amp;m,&amp;amp;q);
    for(int i=1;i&amp;lt;=n;++i){
        scanf(&quot;%s&quot;,mpt[i]+1);
    }
    for(int i=1;i&amp;lt;=q;++i){
        scanf(&quot;%s&quot;,str[i]);
        add(str[i],i);
    }

    for(int i=1;i&amp;lt;=n;++i){
        for(int j=1;j&amp;lt;=m;++j){
            int p = mpt[i][j] -&apos;a&apos;;
            if(judge(i,j,Next[0][p])){
                vis[i][j]=1;
                dfs(i,j,Next[0][p]);
                vis[i][j]=0;
            }
        }
    }
    sort(ans,ans+anscnt);
    for(int i=0;i&amp;lt;anscnt;++i){
        if(i!=0)
            printf(&quot; &quot;);
        printf(&quot;%d&quot;,ans[i]);
    }
    printf(&quot;\n&quot;);
}

return 0;
</code></pre><p>}<br>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="数组变换"><a href="#数组变换" class="headerlink" title="数组变换"></a>数组变换</h2><p>这道题其实不是我想出来的，是队友说的。</p>
<p>解法就是线段树。</p>
<p>其中的难点在于区间异或，我们可以把每一个数转换为二进制，根据数据范围拆成31颗线段树，那么求和就转换成了求区间内1的个数，再对应转换为10进制。而异或就变成了1与0的个数交换或者不变。</p>
<p>加法操作是随便加的，没有难度。</p>
<p>注意写代码的姿势，姿势不好也是会超时的，比如用结构体，比如不用位运算，都是会超时的。</p>
<p>&nbsp;</p>
<p>标程：</p>
<p><pre class="lang:c++ decode:true ">#include&lt;cstdio&gt;</pre></p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>#include&lt;cstring&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;string&gt;</p>
<p>#include&lt;map&gt;<br>using namespace std;</p>
<p>#define pb push_back</p>
<p>#define LL long long</p>
<p>#define N 100005</p>
<p>#define INF 1&lt;&lt;30</p>
<p>#define BIT 31</p>
<p>#define lson l,m,rt&lt;&lt;1</p>
<p>#define rson m+1,r,rt&lt;&lt;1|1</p>
<p>LL sum[N&lt;&lt;2][BIT];<br>LL lazy[N&lt;&lt;2][BIT];</p>
<p>void pushup(int rt){<br>    for(int i=0;i&lt;BIT;++i){<br>        sum[rt][i]=sum[rt&lt;&lt;1][i]+sum[rt&lt;&lt;1|1][i];<br>    }<br>}</p>
<p>void pushdown(int l,int r,int rt){<br>    for(int i=0;i&lt;BIT;++i){<br>        if(lazy[rt][i]){<br>            int m=(l+r)&gt;&gt;1;<br>            lazy[rt&lt;&lt;1][i]^=lazy[rt][i];<br>            lazy[rt&lt;&lt;1|1][i]^=lazy[rt][i];<br>            sum[rt&lt;&lt;1][i]=(m-l+1)-sum[rt&lt;&lt;1][i];<br>            sum[rt&lt;&lt;1|1][i]=(r-m)-sum[rt&lt;&lt;1|1][i];<br>            lazy[rt][i]=0;<br>        }<br>    }<br>}</p>
<p>void build(int l,int r,int rt){<br>    memset(lazy[rt],0,sizeof(lazy[rt]));<br>    if(l==r){<br>        int num;<br>        scanf(“%d”,&amp;num);<br>        for(int i=0;i&lt;BIT;++i){<br>            sum[rt][i]=(num&gt;&gt;i)&amp;1;<br>        }<br>        return;<br>    }<br>    int m=(l+r)&gt;&gt;1;<br>    build(lson);<br>    build(rson);<br>    pushup(rt);<br>}</p>
<p>void update_add(int x,LL p,int l,int r,int rt){<br>    if(l==r){<br>        LL num=0;<br>        for(int i=0;i&lt;BIT;++i){<br>            num+=(sum[rt][i]&lt;&lt;i);<br>        }<br>        num+=p;<br>        for(int i=0;i&lt;BIT;++i){<br>            sum[rt][i]=(num&gt;&gt;i)&amp;1;<br>        }<br>        return;<br>    }<br>    pushdown(l,r,rt);<br>    int m=(l+r)&gt;&gt;1;<br>    if(x&lt;=m) update_add(x,p,lson);<br>    else    update_add(x,p,rson);<br>    pushup(rt);<br>}</p>
<p>void update_xor(int L,int R,LL c,int l,int r,int rt){<br>    if(L&lt;=l&amp;&amp;r&lt;=R){<br>        for(int i=0;i&lt;BIT;++i){<br>            sum[rt][i]=((c&gt;&gt;i)&amp;1)?((r-l+1)-sum[rt][i]):(sum[rt][i]);<br>            lazy[rt][i]^=((c&gt;&gt;i)&amp;1);<br>        }<br>        return;<br>    }<br>    pushdown(l,r,rt);<br>    int m=(l+r)&gt;&gt;1;<br>    if(L&lt;=m) update_xor(L,R,c,lson);<br>    if(R&gt;m)   update_xor(L,R,c,rson);<br>    pushup(rt);<br>}</p>
<p>LL query(int L,int R,int l,int r,int rt){<br>    LL ret=0;<br>    if(L&lt;=l&amp;&amp;r&lt;=R){<br>        for(int i=0;i&lt;BIT;++i){<br>            ret+=(sum[rt][i]&lt;&lt;i);<br>        }<br>        return ret;<br>    }</p>
<pre><code>pushdown(l,r,rt);
int m=(l+r)&amp;gt;&amp;gt;1;
if(L&amp;lt;=m) ret+=query(L,R,lson);
if(R&amp;gt;m)   ret+=query(L,R,rson);
pushup(rt);
return ret;
</code></pre><p>}</p>
<p>int main(){<br>    //freopen(“C:\Users\F\Desktop\in.txt”, “r”, stdin);<br>    //freopen(“C:\Users\F\Desktop\out.txt”, “w”, stdout);<br>    int T;<br>    int n,q;<br>    int a,b,k;<br>    int op;<br>    scanf(“%d”,&amp;T);<br>    while(T–){<br>        scanf(“%d%d”,&amp;n,&amp;q);<br>        build(1,n,1);<br>        while(q–){<br>            scanf(“%d%d%d”,&amp;op,&amp;a,&amp;b);<br>            if(op==1){<br>                update_add(a,b,1,n,1);<br>            }else if(op==2){<br>                scanf(“%d”,&amp;k);<br>                update_xor(a,b,k,1,n,1);<br>            }else if(op==3){<br>                printf(“%lld\n”,query(a,b,1,n,1));<br>            }<br>        }<br>    }<br>    return 0;<br>}<br><br>&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>这道题没什么难度，就是拼模板。。。</p>
<p>通过运用简单的排列组合知识可以推出公式$$ans=(K^L\times C_{L}^{M}\times (K-1)^M / 2) \ mod \ N$$</p>
<p>因为K或者K-1必有一个为偶数，所以不用求逆元</p>
<p>难点就在于$$C_{L}^{M} \ mod \ N$$</p>
<p>因为N不一定为素数，就可以把它分解为$$N=\prod <em>{i=1}^{k} p</em>{i}^{t_i},(k=1,2,3…)$$的形式，$$p_i$$为素数</p>
<p>可以求出所有的$$C_{L}^{M} \ mod \ p_{i}^{t_i}$$，再用中国剩余定理合并</p>
<p>至于求$$C_{L}^{M} \ mod \ p_{i}^{t_i}$$，可以直接用lucas的模板解出</p>
<p>&nbsp;</p>
<p>标程：</p>
<p><pre class="lang:c++ decode:true ">#include&lt;cstdio&gt;</pre></p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cstring&gt;<br>using namespace std;</p>
<p>#define pb push_back</p>
<p>#define LL long long</p>
<p>#define INF 1&lt;&lt;30</p>
<p>LL N,K,L,M;</p>
<p>LL POW(LL a,LL b,LL mod)<br>{<br>    LL ans=1;<br>    while(b)<br>    {<br>        if(b&amp;1) ans=ans<em>a%mod;<br>        a=a</em>a%mod;<br>        b&gt;&gt;=1;<br>    }<br>    return ans;<br>}</p>
<p>LL POW(LL a,LL b)<br>{<br>    LL ans=1;<br>    while(b)<br>    {<br>        if(b&amp;1) ans=ans<em>a;<br>        a=a</em>a;<br>        b&gt;&gt;=1;<br>    }<br>    return ans;<br>}</p>
<p>LL extend_gcd(LL a,LL b,LL &amp;x,LL &amp;y) {<br>    if(a==0&amp;&amp;b==0) return -1;<br>    if(b==0) {<br>        x=1;<br>        y=0;<br>        return a;<br>    }<br>    LL d=extend_gcd(b,a%b,y,x);<br>    y-=a/b*x;<br>    return d;<br>}</p>
<p>bool modular(LL a[],LL m[],LL k)<br>{<br>    LL d,t,c,x,y,i;</p>
<pre><code>for(i=2;i&amp;lt;=k;i++)
{
    d=extend_gcd(m[1],m[i],x,y);
    c=a[i]-a[1];
    if(c%d) return false;
    t=m[i]/d;
    x=(c/d*x%t+t)%t;
    a[1]=m[1]*x+a[1];
    m[1]=m[1]*m[i]/d;
}
return true;
</code></pre><p>}</p>
<p>LL inv(LL a,LL n) {<br>    LL x,y;<br>    LL d=extend_gcd(a,n,x,y);<br>    if(d==1) return (x%n+n)%n;<br>    else return -1;<br>}</p>
<p>LL C(LL n,LL m,LL mod)<br>{<br>    if(m&gt;n) return 0;<br>    LL ans=1,i,a,b;<br>    for(i=1;i&lt;=m;i++)<br>    {<br>        a=(n+1-i)%mod;<br>        b=inv(i%mod,mod);<br>        ans=ans<em>a%mod</em>b%mod;<br>    }<br>    return ans;<br>}</p>
<p>LL C1(LL n,LL m,LL mod)<br>{<br>    if(m==0) return 1;<br>    return C(n%mod,m%mod,mod)*C1(n/mod,m/mod,mod)%mod;<br>}</p>
<p>LL cal(LL n,LL p,LL t)<br>{<br>    if(!n) return 1;<br>    LL x=POW(p,t),i,y=n/x,temp=1;<br>    for(i=1;i&lt;=x;i++) if(i%p) temp=temp<em>i%x;<br>    LL ans=POW(temp,y,x);<br>    for(i=y</em>x+1;i&lt;=n;i++) if(i%p) ans=ans<em>i%x;<br>    return ans</em>cal(n/p,p,t)%x;<br>}</p>
<p>LL C2(LL n,LL m,LL p,LL t)<br>{<br>    LL x=POW(p,t);<br>    LL a,b,c,ap=0,bp=0,cp=0,temp;<br>    for(temp=n;temp;temp/=p) ap+=temp/p;<br>    for(temp=m;temp;temp/=p) bp+=temp/p;<br>    for(temp=n-m;temp;temp/=p) cp+=temp/p;<br>    ap=ap-bp-cp;<br>    LL ans=POW(p,ap,x);<br>    a=cal(n,p,t);<br>    b=cal(m,p,t);<br>    c=cal(n-m,p,t);<br>    ans=ans<em>a%x</em>inv(b,x)%x*inv(c,x)%x;<br>    return ans;<br>}</p>
<p>//C(n,m)%mod<br>LL Lucas(LL n,LL m,LL mod)<br>{<br>    LL i,t,cnt=0;<br>    LL A[205],M[205];<br>    for(i=2;i*i&lt;=mod;i++) if(mod%i==0)<br>    {<br>        t=0;<br>        while(mod%i==0)<br>        {<br>            t++;<br>            mod/=i;<br>        }<br>        M[++cnt]=POW(i,t);<br>        if(t==1) A[cnt]=C1(n,m,i);<br>        else A[cnt]=C2(n,m,i,t);<br>    }<br>    if(mod&gt;1)<br>    {<br>        M[++cnt]=mod;<br>        A[cnt]=C1(n,m,mod);<br>    }<br>    modular(A,M,cnt);<br>    return A[1];<br>}</p>
<p>LL solve()<br>{<br>    if(!M) return POW(K,L,N)+1;<br>    LL ans=1;<br>    if(K&amp;1) ans=ans<em>POW(K,L,N)</em>(K-1)/2%N<em>POW(K-1,M-1,N)%N;<br>    else ans=ans</em>POW(K-1,M,N)<em>K/2%N</em>POW(K,L-1,N)%N;<br>    ans=ans*Lucas(L,M,N)%N;<br>    return ans+1;<br>}</p>
<p>int main()<br>{<br>    //freopen(“C:\Users\F\Desktop\in.txt”, “r”, stdin);<br>    //freopen(“C:\Users\F\Desktop\out.txt”, “w”, stdout);<br>    int T;<br>    scanf(“%d”,&amp;T);<br>    while(T–)<br>    {<br>        scanf(“%lld%lld%lld%lld”,&amp;N,&amp;L,&amp;K,&amp;M);<br>        printf(“%lld\n”,solve());<br>    }<br>    return 0;<br>}<br><br>&nbsp;</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/785902.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#镜像翻转"><span class="toc-number">1.</span> <span class="toc-text">镜像翻转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符矩阵"><span class="toc-number">2.</span> <span class="toc-text">字符矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组变换"><span class="toc-number">3.</span> <span class="toc-text">数组变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板题"><span class="toc-number">4.</span> <span class="toc-text">模板题</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="../js/plugin.js"></script>
<script src="../js/diaspora.js"></script>
<link rel="stylesheet" href="../photoswipe/photoswipe.css">
<link rel="stylesheet" href="../photoswipe/default-skin/default-skin.css">
<script src="../photoswipe/photoswipe.min.js"></script>
<script src="../photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>