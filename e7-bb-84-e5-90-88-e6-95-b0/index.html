
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>xuan&#39;s blog</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="xuan,"> 
    
    <meta name="author" content="xuan"> 
    <link rel="alternative" href="atom.xml" title="xuan&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="../img/favicon.ico"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="../css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single" class="page">
    <div id="top">
        <a class="icon-left image-icon" href="javascript:history.back()"></a>
    </div>
    <div class="section">
        <div class="article">
            <div class="main">
                <div class="content">
                    <p>组合数公式：</p>
<p>$$C_n^m= \frac{n!}{n!(n-m)!}$$</p>
<p>性质：</p>
<p>$$C_n^m=C_n^{n-m}$$</p>
<p>$$C_n^m= C_{n-1}^{m-1}+C_{n-1}^m$$</p>
<p>&nbsp;</p>
<h2 id="求-C-m-n-mod-p"><a href="#求-C-m-n-mod-p" class="headerlink" title="求$$C^m_n mod\ p$$"></a>求$$C^m_n mod\ p$$</h2><h4 id="1-1-leqslant-m-leqslant-n-leqslant-10-3-1-leqslant-p-leqslant-10-9"><a href="#1-1-leqslant-m-leqslant-n-leqslant-10-3-1-leqslant-p-leqslant-10-9" class="headerlink" title="(1)$$1 \leqslant m \leqslant n \leqslant 10^3,1 \leqslant p \leqslant 10^9$$"></a>(1)$$1 \leqslant m \leqslant n \leqslant 10^3,1 \leqslant p \leqslant 10^9$$</h4><p>1、利用性质递归求解</p>
<pre class="lang:c++ decode:true">int C(int n,int m,int p){
    if(m&gt;n) return 0;
    if(n==m||m==0)return 1;
    if(n==m+1||m==1)return n%p;
    return (C(n-1,m-1,p)+C(n-1,m,p))%p;
}
</pre>
&nbsp;

2、可以直接利用杨辉三角
<pre class="lang:c++ decode:true">void init(){
    int c[N][N]={0};//c(n,m)=c[n][m];
    for(int i=1;i&lt;=N;i++) {
        for(int j=1;j&lt;=i;j++) {
            if(j==1||i==j)
                c[i][j]=1;
            else
                c[i][j]=(c[i-1][j-1]+c[i-1][j])%p;
        }
    }
}</pre>

<hr>
<p>&nbsp;</p>
<h4 id="2-1-leqslant-m-leqslant-n-leqslant-10-5-1-leqslant-p-leqslant-10-9-且-p-为素数"><a href="#2-1-leqslant-m-leqslant-n-leqslant-10-5-1-leqslant-p-leqslant-10-9-且-p-为素数" class="headerlink" title="(2)$$1 \leqslant m \leqslant n \leqslant 10^5,1\leqslant p \leqslant 10^9 $$且 $$p$$为素数"></a>(2)$$1 \leqslant m \leqslant n \leqslant 10^5,1\leqslant p \leqslant 10^9 $$且 $$p$$为素数</h4><pre class="lang:c++ decode:true">LL fac[N];
//预处理阶乘
void init(LL p){
    fac[0]=1;
    for(int i=1;i&lt;p;++i)
        fac[i]=fac[i-1]*i%p
}

//返回d=gcd(a,b);和对应于等式ax+by=d中的x,y
LL extend_gcd(LL a,LL b,LL &amp;x,LL &amp;y) {
    if(a==0&amp;&amp;b==0) return -1;//无最大公约数
    if(b==0) {
        x=1;
        y=0;
        return a;
    }
    LL d=extend_gcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
//ax = 1(mod n)
LL inv(LL a,LL n) {
    LL x,y;
    LL d=extend_gcd(a,n,x,y);
    if(d==1) return (x%n+n)%n;
    else return -1;
}

LL C(LL n,LL m,LL p){
    if(m&gt;n) return 0;
    if(n==m||m==0)return 1;
    if(n==m+1||m==1)return n;
    return fac[n]*inv(fac[m]*fac[n-m]%p,p)%p;
}</pre>

<hr>
<p>#### </p>
<h4 id="3-1-leqslant-n-leqslant-10-18-1-leqslant-m-leqslant-10-5-1-leqslant-p-leqslant-10-9-且-p-为素数"><a href="#3-1-leqslant-n-leqslant-10-18-1-leqslant-m-leqslant-10-5-1-leqslant-p-leqslant-10-9-且-p-为素数" class="headerlink" title="(3)$$1\leqslant n\leqslant 10^{18}, 1\leqslant m\leqslant 10^5,1\leqslant p\leqslant 10^9$$且$$p$$为素数"></a>(3)$$1\leqslant n\leqslant 10^{18}, 1\leqslant m\leqslant 10^5,1\leqslant p\leqslant 10^9$$且$$p$$为素数</h4><p><strong>Lucas定理：</strong><br><strong> $$n=n_k p^k+n_{k-1} p^{k-1}+\cdots n_1 p + n_0$$</strong><br><strong> $$m=m_k p^k+m_{k-1} p^{k-1}+\cdots m_1 p + m_0$$</strong><br><strong> 那么</strong><br><strong> $$C^m_n= \prod_{i=0}^{k} C^{m_i}_{n_i}(mod \ p)$$</strong></p>
<p>若$$1 \leqslant p \leqslant 10^5 $$可用$$(2)$$中的方法预处理阶乘</p>
<pre class="lang:c++ decode:true">//返回d=gcd(a,b);和对应于等式ax+by=d中的x,y
LL extend_gcd(LL a,LL b,LL &amp;x,LL &amp;y) {
    if(a==0&amp;&amp;b==0) return -1;//无最大公约数
    if(b==0) {
        x=1;
        y=0;
        return a;
    }
    LL d=extend_gcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
//ax = 1(mod n)
LL inv(LL a,LL n) {
    LL x,y;
    LL d=extend_gcd(a,n,x,y);
    if(d==1) return (x%n+n)%n;
    else return -1;
}

LL C(LL n,LL m,LL p)
{
    if(m&gt;n) return 0;
    if(n==m||m==0)return 1;
    if(n==m+1||m==1)return n;
    LL ans=1;
    for(LL i=1;i&lt;=m;i++){
        LL a=(n+i-m)%p;
        LL b=i%p;
        ans=ans*(a*inv(b,p)%p)%p;
    }
    return ans;
}

//C(n,m)%p,p为素数
LL lucas(LL n,LL m,LL p)
{
    if(m==0) return 1;
    return C(n%p,m%p,p)*lucas(n/p,m/p,p)%p;
}</pre>

<hr>
<p>&nbsp;</p>
<h4 id="4-1-leqslant-m-leqslant-n-leqslant-10-6-1-leqslant-q-leqslant-10-9-，-p-可为合数"><a href="#4-1-leqslant-m-leqslant-n-leqslant-10-6-1-leqslant-q-leqslant-10-9-，-p-可为合数" class="headerlink" title="(4)$$1 \leqslant m \leqslant n \leqslant 10^6 ,1 \leqslant q \leqslant 10^9$$，$$p$$可为合数"></a>(4)$$1 \leqslant m \leqslant n \leqslant 10^6 ,1 \leqslant q \leqslant 10^9$$，$$p$$可为合数</h4><pre class="lang:c++ decode:true ">int tot;//小于N的素数个数
int prime[N];//存小于N的素数
bool isprime[N+10];//isprime[n]==1为素数

void getprime() {
    tot=0;
    memset(isprime,true,sizeof(isprime));
    isprime[0]=isprime[1]=0;
    for(int i=2; i&lt;=N; ++i) {
        if(isprime[i])prime[tot++]=i;
        for(int j=0; j&lt;tot; j++) {
            if(i*prime[j]&gt;N)break;
            isprime[i*prime[j]]=0;
            if(i%prime[j]==0)break;
        }
    }
}

LL quickpow(LL a,LL b,LL p) {
    LL ret=1;
    while(b) {
        if(b&amp;1)ret=(ret*a)%p;
        a=(a*a)%p;
        b&gt;&gt;=1;
    }
    return ret;
}

LL cal(LL n,LL p) {
    LL ans = 0;
    while(n) {
        ans += n / p;
        n /= p;
    }
    return ans;
}

LL C(LL n,LL m,LL p) {
    LL ans = 1;
    for(int i=0; i&lt;tot &amp;&amp; prime[i]&lt;=n; i++) {
        LL x = cal(n, prime[i]);
        LL y = cal(n - m, prime[i]);
        LL z = cal(m, prime[i]);
        x -= (y + z);
        ans *= quickpow(prime[i],x,p);
        ans %= p;
    }
    return ans;
}</pre>

<hr>
<p>&nbsp;</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3944" target="_blank" rel="noopener">HDU 3944 DP?</a></p>
<p>$$T=10^5,1 \leqslant m \leqslant n \leqslant 10^9$$，$$1 \leqslant p \leqslant 10^4 $$且$$p$$为素数</p>
<p>预处理出阶乘和阶乘的逆</p>
<pre class="lang:c++ decode:true ">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
#define LL __int64
#define N 10005

int fac[N][N];
int ni[N][N];

int tot;//小于N的素数个数
int prime[N];//存小于N的素数
bool isprime[N];//isprime[n]==1为素数

void init() {
    //筛素数
    tot=0;
    memset(isprime,true,sizeof(isprime));
    isprime[0]=isprime[1]=0;
    for(int i=2; i&lt;N; ++i) {
        if(isprime[i]){
            prime[tot++]=i;
            //预处理阶乘取模
            fac[i][1]=1;
            for(int j=2;j&lt;i;j++)
                fac[i][j]=fac[i][j-1]*j%i;
            //预处理阶乘逆
            ni[i][1]=1;
            for(int j=2;j&lt;i;j++)
                ni[i][j]=(-i/j*ni[i][i%j]+i)%i;
        }
        for(int j=0; j&lt;tot; j++) {
            if(i*prime[j]&gt;=N)break;
            isprime[i*prime[j]]=0;
            if(i%prime[j]==0)break;
        }
    }
    //预处理阶乘逆
    for(int i=0;i&lt;tot;++i){
        for(int j=2;j&lt;prime[i];++j){
            ni[prime[i]][j]=ni[prime[i]][j]*ni[prime[i]][j-1]%prime[i];
        }
    }
}

int C(int n,int m,int p)
{
    if(m&gt;n) return 0;
    if(n==m||m==0)return 1;
    if(n==m+1||m==1)return n%p;
    return fac[p][n]*ni[p][m]%p*ni[p][n-m]%p;
}

//C(n,m)%p,p为素数
int lucas(int n,int m,int p)
{
    if(m==0) return 1;
    return C(n%p,m%p,p)*lucas(n/p,m/p,p)%p;
}

int main(){
    init();
    int n,k,p;
    int cas=1;
    while(~scanf("%d%d%d",&amp;n,&amp;k,&amp;p)){
        if(2*k &lt; n)
            printf("Case #%d: %d\n",cas++,(lucas(n+1,k,p)+n-k)%p);
        else
            printf("Case #%d: %d\n",cas++,(lucas(n+1,k+1,p)+k)%p);
    }
    return 0;

}
</pre>

<hr>
<p>&nbsp;</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5446" target="_blank" rel="noopener">HDU 5446 Unknown Treasure</a></p>
<p>题意：求$$C^m_n \mod M$$,其中$$M$$为$$k$$个不同素数$$p_i$$的乘积。</p>
<p>(1\leqslant m\leqslant n\leqslant 10^{18},1\leqslant k\leqslant 10,M\leqslant 10^{18},p_i\leqslant 10^5)</p>
<p>&nbsp;</p>
<p>Lucas+中国剩余定理</p>
<p>用lucas分别求出</p>
<p>$$A_i =C^m_n \mod p_i$$</p>
<p>得到同余方程组</p>
<p>$$x \equiv A_i(mod \ p_i)$$</p>
<p>用中国剩余定理可求出(x)</p>
<p><pre class="lang:c++ decode:true">#include&lt;cstdio&gt;</pre></p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>#include&lt;cstring&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;string&gt;</p>
<p>#include&lt;map&gt;<br>using namespace std;</p>
<p>#define pb push_back</p>
<p>#define LL long long</p>
<p>#define INF 1&lt;&lt;30</p>
<p>LL a[15],m[15];</p>
<p>LL extend_gcd(LL a,LL b,LL &amp;x,LL &amp;y) {<br>    if(a==0&amp;&amp;b==0) return -1;<br>    if(b==0) {<br>        x=1;<br>        y=0;<br>        return a;<br>    }<br>    LL d=extend_gcd(b,a%b,y,x);<br>    y-=a/b*x;<br>    return d;<br>}</p>
<p>LL inv(LL a,LL n) {<br>    LL x,y;<br>    LL d=extend_gcd(a,n,x,y);<br>    if(d==1) return (x%n+n)%n;<br>    else return -1;<br>}</p>
<p>LL C(LL n,LL k,int cur) {<br>    LL p=m[cur];<br>    if(k&gt;n) return 0;<br>    if(n==k||k==0)return 1;<br>    if(n==k+1||k==1)return n;<br>    LL ans=1;<br>    for(LL i=1; i&lt;=k; i++) {<br>        LL a=(n+i-k)%p;<br>        LL b=i%p;<br>        ans=ans<em>(a</em>inv(b,p)%p)%p;<br>    }<br>    return ans;<br>}</p>
<p>bool solve(LL &amp;m0,LL &amp;a0,int m,int a) {<br>    long long y,x;<br>    int g = extend_gcd(m0,m,x,y);<br>    if(abs(a - a0)%g)return false;<br>    x <em>= (a - a0)/g;<br>    x %= m/g;<br>    a0 = (x</em>m0 + a0);<br>    m0 *= m/g;<br>    a0 %= m0;<br>    if(a0 &lt; 0)a0 += m0;<br>    return true;<br>}</p>
<p>bool MLES(LL &amp;m0 ,LL &amp;a0,int n) {<br>    bool flag = true;<br>    m0 = 1;<br>    a0 = 0;<br>    for(int i = 0; i &lt; n; i++)<br>        if(!solve(m0,a0,m[i],a[i])) {<br>            flag = false;<br>            break;<br>        }<br>    return flag;<br>}</p>
<p>LL Lucas(LL n,LL k,int cur) {<br>    LL p = m[cur];<br>    if(k == 0)  return 1;<br>    return C(n % p, k % p, cur) * Lucas(n / p, k / p, cur) % p;<br>}</p>
<p>int main() {<br>    int T;<br>    LL N,M,K;</p>
<pre><code>scanf(&quot;%d&quot;,&amp;amp;T);
while(T--) {
    memset(a,0,sizeof(a));
    scanf(&quot;%I64d%I64d%I64d&quot;,&amp;amp;N,&amp;amp;M,&amp;amp;K);
    for(int i=0; i&amp;lt;K; ++i)
        scanf(&quot;%I64d&quot;,&amp;amp;m[i]);
    for(int i=0; i&amp;lt;K; ++i) {
        a[i]=Lucas(N,M,i)%m[i];
    }
    LL m0,a0;
    MLES(m0,a0,K);
    printf(&quot;%I64d\n&quot;,a0);
}
return 0;
</code></pre><p>}<br>&nbsp;</p>
<p>&nbsp;</p>

                </div>
            </div>
        </div>
    </div>
</div>

</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="../js/plugin.js"></script>
<script src="../js/diaspora.js"></script>
<link rel="stylesheet" href="../photoswipe/photoswipe.css">
<link rel="stylesheet" href="../photoswipe/default-skin/default-skin.css">
<script src="../photoswipe/photoswipe.min.js"></script>
<script src="../photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>